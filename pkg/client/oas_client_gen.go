// Code generated by ogen, DO NOT EDIT.

package client

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AddGalleryImage invokes addGalleryImage operation.
	//
	// Modrinth allows you to upload files of up to 5MiB to a project's gallery.
	//
	// POST /project/{id|slug}/gallery
	AddGalleryImage(ctx context.Context, request AddGalleryImageReq, params AddGalleryImageParams) (AddGalleryImageRes, error)
	// AddTeamMember invokes addTeamMember operation.
	//
	// Add a user to a team.
	//
	// POST /team/{id}/members
	AddTeamMember(ctx context.Context, request UserIdentifier, params AddTeamMemberParams) (AddTeamMemberRes, error)
	// CategoryList invokes categoryList operation.
	//
	// Gets an array of categories, their icons, and applicable project types.
	//
	// GET /tag/category
	CategoryList(ctx context.Context) ([]CategoryTag, error)
	// ChangeProjectIcon invokes changeProjectIcon operation.
	//
	// The new icon may be up to 256KiB in size.
	//
	// PATCH /project/{id|slug}/icon
	ChangeProjectIcon(ctx context.Context, request ChangeProjectIconReq, params ChangeProjectIconParams) (ChangeProjectIconRes, error)
	// ChangeUserIcon invokes changeUserIcon operation.
	//
	// The new avatar may be up to 2MiB in size.
	//
	// PATCH /user/{id|username}/icon
	ChangeUserIcon(ctx context.Context, request ChangeUserIconReq, params ChangeUserIconParams) (ChangeUserIconRes, error)
	// CheckProjectValidity invokes checkProjectValidity operation.
	//
	// Check project slug/ID validity.
	//
	// GET /project/{id|slug}/check
	CheckProjectValidity(ctx context.Context, params CheckProjectValidityParams) (CheckProjectValidityRes, error)
	// CreateVersion invokes createVersion operation.
	//
	// This route creates a version on an existing project. There must be at least one file attached to
	// each new version, unless the new version's status is `draft`. `.mrpack`, `.jar`, `.zip`, and `.
	// litemod` files are accepted.
	// The request is a [multipart request](https://www.ietf.org/rfc/rfc2388.txt) with at least two form
	// fields: one is `data`, which includes a JSON body with the version metadata as shown below, and at
	// least one field containing an upload file.
	// You can name the file parts anything you would like, but you must list each of the parts' names in
	// `file_parts`, and optionally, provide one to use as the primary file in `primary_file`.
	//
	// POST /version
	CreateVersion(ctx context.Context, request OptCreateVersionBodyMultipart) (CreateVersionRes, error)
	// DeleteFileFromHash invokes deleteFileFromHash operation.
	//
	// Delete a file from its hash.
	//
	// DELETE /version_file/{hash}
	DeleteFileFromHash(ctx context.Context, params DeleteFileFromHashParams) (DeleteFileFromHashRes, error)
	// DeleteGalleryImage invokes deleteGalleryImage operation.
	//
	// Delete a gallery image.
	//
	// DELETE /project/{id|slug}/gallery
	DeleteGalleryImage(ctx context.Context, params DeleteGalleryImageParams) (DeleteGalleryImageRes, error)
	// DeleteNotification invokes deleteNotification operation.
	//
	// Delete notification.
	//
	// DELETE /notification/{id}
	DeleteNotification(ctx context.Context, params DeleteNotificationParams) (DeleteNotificationRes, error)
	// DeleteNotifications invokes deleteNotifications operation.
	//
	// Delete multiple notifications.
	//
	// DELETE /notifications
	DeleteNotifications(ctx context.Context, params DeleteNotificationsParams) (DeleteNotificationsRes, error)
	// DeleteProject invokes deleteProject operation.
	//
	// Delete a project.
	//
	// DELETE /project/{id|slug}
	DeleteProject(ctx context.Context, params DeleteProjectParams) (DeleteProjectRes, error)
	// DeleteProjectIcon invokes deleteProjectIcon operation.
	//
	// Delete project's icon.
	//
	// DELETE /project/{id|slug}/icon
	DeleteProjectIcon(ctx context.Context, params DeleteProjectIconParams) (DeleteProjectIconRes, error)
	// DeleteTeamMember invokes deleteTeamMember operation.
	//
	// Remove a member from a team.
	//
	// DELETE /team/{id}/members/{id|username}
	DeleteTeamMember(ctx context.Context, params DeleteTeamMemberParams) (DeleteTeamMemberRes, error)
	// DeleteThreadMessage invokes deleteThreadMessage operation.
	//
	// Delete a thread message.
	//
	// DELETE /message/{id}
	DeleteThreadMessage(ctx context.Context, params DeleteThreadMessageParams) (DeleteThreadMessageRes, error)
	// DeleteUserIcon invokes deleteUserIcon operation.
	//
	// Remove user's avatar.
	//
	// DELETE /user/{id|username}/icon
	DeleteUserIcon(ctx context.Context, params DeleteUserIconParams) (DeleteUserIconRes, error)
	// DeleteVersion invokes deleteVersion operation.
	//
	// Delete a version.
	//
	// DELETE /version/{id}
	DeleteVersion(ctx context.Context, params DeleteVersionParams) (DeleteVersionRes, error)
	// DonationPlatformList invokes donationPlatformList operation.
	//
	// Gets an array of donation platforms and information about them.
	//
	// GET /tag/donation_platform
	DonationPlatformList(ctx context.Context) ([]DonationPlatformTag, error)
	// FollowProject invokes followProject operation.
	//
	// Follow a project.
	//
	// POST /project/{id|slug}/follow
	FollowProject(ctx context.Context, params FollowProjectParams) (FollowProjectRes, error)
	// ForgeUpdates invokes forgeUpdates operation.
	//
	// If you're a Forge mod developer, your Modrinth mods have an automatically generated `updates.json`
	// using the
	// [Forge Update Checker](https://docs.minecraftforge.net/en/latest/misc/updatechecker/).
	// The only setup is to insert the URL into the `[[mods]]` section of your `mods.toml` file as such:
	// ```toml
	// [[mods]]
	// # the other stuff here - ID, version, display name, etc.
	// updateJSONURL = "https://api.modrinth.com/updates/{slug|ID}/forge_updates.json"
	// ```
	// Replace `{slug|id}` with the slug or ID of your project.
	// Modrinth will handle the rest! When you update your mod, Forge will notify your users that their
	// copy of your mod is out of date.
	// Make sure that the version format you use for your Modrinth releases is the same as the version
	// format you use in your `mods.toml`.
	// If you use a format such as `1.2.3-forge` or `1.2.3+1.19` with your Modrinth releases but your
	// `mods.toml` only has `1.2.3`,
	// the update checker may not function properly.
	//
	// GET /updates/{id|slug}/forge_updates.json
	ForgeUpdates(ctx context.Context, params ForgeUpdatesParams) (ForgeUpdatesRes, error)
	// GetDependencies invokes getDependencies operation.
	//
	// Get all of a project's dependencies.
	//
	// GET /project/{id|slug}/dependencies
	GetDependencies(ctx context.Context, params GetDependenciesParams) (GetDependenciesRes, error)
	// GetFollowedProjects invokes getFollowedProjects operation.
	//
	// Get user's followed projects.
	//
	// GET /user/{id|username}/follows
	GetFollowedProjects(ctx context.Context, params GetFollowedProjectsParams) (GetFollowedProjectsRes, error)
	// GetLatestVersionFromHash invokes getLatestVersionFromHash operation.
	//
	// Latest version of a project from a hash, loader(s), and game version(s).
	//
	// POST /version_file/{hash}/update
	GetLatestVersionFromHash(ctx context.Context, request OptGetLatestVersionFromHashBody, params GetLatestVersionFromHashParams) (GetLatestVersionFromHashRes, error)
	// GetLatestVersionsFromHashes invokes getLatestVersionsFromHashes operation.
	//
	// This is the same as [`/version_file/{hash}/update`](#operation/getLatestVersionFromHash) except it
	// accepts multiple hashes.
	//
	// POST /version_files/update
	GetLatestVersionsFromHashes(ctx context.Context, request OptGetLatestVersionsFromHashesBody) (GetLatestVersionsFromHashesRes, error)
	// GetNotification invokes getNotification operation.
	//
	// Get notification from ID.
	//
	// GET /notification/{id}
	GetNotification(ctx context.Context, params GetNotificationParams) (GetNotificationRes, error)
	// GetNotifications invokes getNotifications operation.
	//
	// Get multiple notifications.
	//
	// GET /notifications
	GetNotifications(ctx context.Context, params GetNotificationsParams) (GetNotificationsRes, error)
	// GetOpenReports invokes getOpenReports operation.
	//
	// Get your open reports.
	//
	// GET /report
	GetOpenReports(ctx context.Context, params GetOpenReportsParams) (GetOpenReportsRes, error)
	// GetPayoutHistory invokes getPayoutHistory operation.
	//
	// Get user's payout history.
	//
	// GET /user/{id|username}/payouts
	GetPayoutHistory(ctx context.Context, params GetPayoutHistoryParams) (GetPayoutHistoryRes, error)
	// GetProject invokes getProject operation.
	//
	// Get a project.
	//
	// GET /project/{id|slug}
	GetProject(ctx context.Context, params GetProjectParams) (GetProjectRes, error)
	// GetProjectTeamMembers invokes getProjectTeamMembers operation.
	//
	// Get a project's team members.
	//
	// GET /project/{id|slug}/members
	GetProjectTeamMembers(ctx context.Context, params GetProjectTeamMembersParams) (GetProjectTeamMembersRes, error)
	// GetProjectVersions invokes getProjectVersions operation.
	//
	// List project's versions.
	//
	// GET /project/{id|slug}/version
	GetProjectVersions(ctx context.Context, params GetProjectVersionsParams) (GetProjectVersionsRes, error)
	// GetProjects invokes getProjects operation.
	//
	// Get multiple projects.
	//
	// GET /projects
	GetProjects(ctx context.Context, params GetProjectsParams) ([]Project, error)
	// GetReport invokes getReport operation.
	//
	// Get report from ID.
	//
	// GET /report/{id}
	GetReport(ctx context.Context, params GetReportParams) (GetReportRes, error)
	// GetReports invokes getReports operation.
	//
	// Get multiple reports.
	//
	// GET /reports
	GetReports(ctx context.Context, params GetReportsParams) (GetReportsRes, error)
	// GetTeamMembers invokes getTeamMembers operation.
	//
	// Get a team's members.
	//
	// GET /team/{id}/members
	GetTeamMembers(ctx context.Context, params GetTeamMembersParams) ([]TeamMember, error)
	// GetTeams invokes getTeams operation.
	//
	// Get the members of multiple teams.
	//
	// GET /teams
	GetTeams(ctx context.Context, params GetTeamsParams) ([][]TeamMember, error)
	// GetThread invokes getThread operation.
	//
	// Get a thread.
	//
	// GET /thread/{id}
	GetThread(ctx context.Context, params GetThreadParams) (GetThreadRes, error)
	// GetThreads invokes getThreads operation.
	//
	// Get multiple threads.
	//
	// GET /threads
	GetThreads(ctx context.Context, params GetThreadsParams) (GetThreadsRes, error)
	// GetUser invokes getUser operation.
	//
	// Get a user.
	//
	// GET /user/{id|username}
	GetUser(ctx context.Context, params GetUserParams) (GetUserRes, error)
	// GetUserFromAuth invokes getUserFromAuth operation.
	//
	// Get user from authorization header.
	//
	// GET /user
	GetUserFromAuth(ctx context.Context) (GetUserFromAuthRes, error)
	// GetUserNotifications invokes getUserNotifications operation.
	//
	// Get user's notifications.
	//
	// GET /user/{id|username}/notifications
	GetUserNotifications(ctx context.Context, params GetUserNotificationsParams) (GetUserNotificationsRes, error)
	// GetUserProjects invokes getUserProjects operation.
	//
	// Get user's projects.
	//
	// GET /user/{id|username}/projects
	GetUserProjects(ctx context.Context, params GetUserProjectsParams) (GetUserProjectsRes, error)
	// GetUsers invokes getUsers operation.
	//
	// Get multiple users.
	//
	// GET /users
	GetUsers(ctx context.Context, params GetUsersParams) ([]User, error)
	// GetVersion invokes getVersion operation.
	//
	// Get a version.
	//
	// GET /version/{id}
	GetVersion(ctx context.Context, params GetVersionParams) (GetVersionRes, error)
	// GetVersionFromIdOrNumber invokes getVersionFromIdOrNumber operation.
	//
	// Please note that, if the version number provided matches multiple versions, only the **oldest
	// matching version** will be returned.
	//
	// GET /project/{id|slug}/version/{id|number}
	GetVersionFromIdOrNumber(ctx context.Context, params GetVersionFromIdOrNumberParams) (GetVersionFromIdOrNumberRes, error)
	// GetVersions invokes getVersions operation.
	//
	// Get multiple versions.
	//
	// GET /versions
	GetVersions(ctx context.Context, params GetVersionsParams) ([]Version, error)
	// JoinTeam invokes joinTeam operation.
	//
	// Join a team.
	//
	// POST /team/{id}/join
	JoinTeam(ctx context.Context, params JoinTeamParams) (JoinTeamRes, error)
	// LicenseList invokes licenseList operation.
	//
	// Deprecated - simply use SPDX IDs.
	//
	// Deprecated: schema marks this operation as deprecated.
	//
	// GET /tag/license
	LicenseList(ctx context.Context) ([]LicenseTag, error)
	// LicenseText invokes licenseText operation.
	//
	// Get the text and title of a license.
	//
	// GET /tag/license/{id}
	LicenseText(ctx context.Context, params LicenseTextParams) (LicenseTextRes, error)
	// LoaderList invokes loaderList operation.
	//
	// Gets an array of loaders, their icons, and supported project types.
	//
	// GET /tag/loader
	LoaderList(ctx context.Context) ([]LoaderTag, error)
	// ModifyGalleryImage invokes modifyGalleryImage operation.
	//
	// Modify a gallery image.
	//
	// PATCH /project/{id|slug}/gallery
	ModifyGalleryImage(ctx context.Context, params ModifyGalleryImageParams) (ModifyGalleryImageRes, error)
	// ModifyProject invokes modifyProject operation.
	//
	// Modify a project.
	//
	// PATCH /project/{id|slug}
	ModifyProject(ctx context.Context, request OptEditableProject, params ModifyProjectParams) (ModifyProjectRes, error)
	// ModifyReport invokes modifyReport operation.
	//
	// Modify a report.
	//
	// PATCH /report/{id}
	ModifyReport(ctx context.Context, request OptModifyReportReq, params ModifyReportParams) (ModifyReportRes, error)
	// ModifyTeamMember invokes modifyTeamMember operation.
	//
	// Modify a team member's information.
	//
	// PATCH /team/{id}/members/{id|username}
	ModifyTeamMember(ctx context.Context, request ModifyTeamMemberBody, params ModifyTeamMemberParams) (ModifyTeamMemberRes, error)
	// ModifyUser invokes modifyUser operation.
	//
	// Modify a user.
	//
	// PATCH /user/{id|username}
	ModifyUser(ctx context.Context, request OptEditableUser, params ModifyUserParams) (ModifyUserRes, error)
	// ModifyVersion invokes modifyVersion operation.
	//
	// Modify a version.
	//
	// PATCH /version/{id}
	ModifyVersion(ctx context.Context, request OptEditableVersion, params ModifyVersionParams) (ModifyVersionRes, error)
	// PatchProjects invokes patchProjects operation.
	//
	// Bulk-edit multiple projects.
	//
	// PATCH /projects
	PatchProjects(ctx context.Context, request OptPatchProjectsBody, params PatchProjectsParams) (PatchProjectsRes, error)
	// ProjectTypeList invokes projectTypeList operation.
	//
	// Gets an array of valid project types.
	//
	// GET /tag/project_type
	ProjectTypeList(ctx context.Context) ([]string, error)
	// RandomProjects invokes randomProjects operation.
	//
	// Get a list of random projects.
	//
	// GET /projects_random
	RandomProjects(ctx context.Context, params RandomProjectsParams) (RandomProjectsRes, error)
	// ReadNotification invokes readNotification operation.
	//
	// Mark notification as read.
	//
	// PATCH /notification/{id}
	ReadNotification(ctx context.Context, params ReadNotificationParams) (ReadNotificationRes, error)
	// ReadNotifications invokes readNotifications operation.
	//
	// Mark multiple notifications as read.
	//
	// PATCH /notifications
	ReadNotifications(ctx context.Context, params ReadNotificationsParams) (ReadNotificationsRes, error)
	// ReportTypeList invokes reportTypeList operation.
	//
	// Gets an array of valid report types.
	//
	// GET /tag/report_type
	ReportTypeList(ctx context.Context) ([]string, error)
	// ScheduleProject invokes scheduleProject operation.
	//
	// Schedule a project.
	//
	// POST /project/{id|slug}/schedule
	ScheduleProject(ctx context.Context, request OptSchedule, params ScheduleProjectParams) (ScheduleProjectRes, error)
	// ScheduleVersion invokes scheduleVersion operation.
	//
	// Schedule a version.
	//
	// POST /version/{id}/schedule
	ScheduleVersion(ctx context.Context, request OptSchedule, params ScheduleVersionParams) (ScheduleVersionRes, error)
	// SearchProjects invokes searchProjects operation.
	//
	// Search projects.
	//
	// GET /search
	SearchProjects(ctx context.Context, params SearchProjectsParams) (SearchProjectsRes, error)
	// SendThreadMessage invokes sendThreadMessage operation.
	//
	// Send a text message to a thread.
	//
	// POST /thread/{id}
	SendThreadMessage(ctx context.Context, request OptThreadMessageBody, params SendThreadMessageParams) (SendThreadMessageRes, error)
	// SideTypeList invokes sideTypeList operation.
	//
	// Gets an array of valid side types.
	//
	// GET /tag/side_type
	SideTypeList(ctx context.Context) ([]string, error)
	// Statistics invokes statistics operation.
	//
	// Various statistics about this Modrinth instance.
	//
	// GET /statistics
	Statistics(ctx context.Context) (*Statistics, error)
	// SubmitReport invokes submitReport operation.
	//
	// Bring a project, user, or version to the attention of the moderators by reporting it.
	//
	// POST /report
	SubmitReport(ctx context.Context, request OptCreatableReport) (SubmitReportRes, error)
	// TransferTeamOwnership invokes transferTeamOwnership operation.
	//
	// Transfer team's ownership to another user.
	//
	// PATCH /team/{id}/owner
	TransferTeamOwnership(ctx context.Context, request UserIdentifier, params TransferTeamOwnershipParams) (TransferTeamOwnershipRes, error)
	// UnfollowProject invokes unfollowProject operation.
	//
	// Unfollow a project.
	//
	// DELETE /project/{id|slug}/follow
	UnfollowProject(ctx context.Context, params UnfollowProjectParams) (UnfollowProjectRes, error)
	// VersionFromHash invokes versionFromHash operation.
	//
	// Get version from hash.
	//
	// GET /version_file/{hash}
	VersionFromHash(ctx context.Context, params VersionFromHashParams) (VersionFromHashRes, error)
	// VersionList invokes versionList operation.
	//
	// Gets an array of game versions and information about them.
	//
	// GET /tag/game_version
	VersionList(ctx context.Context) ([]GameVersionTag, error)
	// VersionsFromHashes invokes versionsFromHashes operation.
	//
	// This is the same as [`/version_file/{hash}`](#operation/versionFromHash) except it accepts
	// multiple hashes.
	//
	// POST /version_files
	VersionsFromHashes(ctx context.Context, request OptHashList) (VersionsFromHashesRes, error)
	// WithdrawPayout invokes withdrawPayout operation.
	//
	// Warning: certain amounts get withheld for fees. Please do not call this API endpoint without first
	// acknowledging the warnings on the corresponding frontend page.
	//
	// POST /user/{id|username}/payouts
	WithdrawPayout(ctx context.Context, params WithdrawPayoutParams) (WithdrawPayoutRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AddGalleryImage invokes addGalleryImage operation.
//
// Modrinth allows you to upload files of up to 5MiB to a project's gallery.
//
// POST /project/{id|slug}/gallery
func (c *Client) AddGalleryImage(ctx context.Context, request AddGalleryImageReq, params AddGalleryImageParams) (AddGalleryImageRes, error) {
	res, err := c.sendAddGalleryImage(ctx, request, params)
	return res, err
}

func (c *Client) sendAddGalleryImage(ctx context.Context, request AddGalleryImageReq, params AddGalleryImageParams) (res AddGalleryImageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/gallery"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ext" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ext",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Ext)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featured" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featured",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.BoolToString(params.Featured))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "title" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "title",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Title.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "description" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "description",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Description.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ordering" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ordering",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ordering.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddGalleryImageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, AddGalleryImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddGalleryImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AddTeamMember invokes addTeamMember operation.
//
// Add a user to a team.
//
// POST /team/{id}/members
func (c *Client) AddTeamMember(ctx context.Context, request UserIdentifier, params AddTeamMemberParams) (AddTeamMemberRes, error) {
	res, err := c.sendAddTeamMember(ctx, request, params)
	return res, err
}

func (c *Client) sendAddTeamMember(ctx context.Context, request UserIdentifier, params AddTeamMemberParams) (res AddTeamMemberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/team/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAddTeamMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, AddTeamMemberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAddTeamMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CategoryList invokes categoryList operation.
//
// Gets an array of categories, their icons, and applicable project types.
//
// GET /tag/category
func (c *Client) CategoryList(ctx context.Context) ([]CategoryTag, error) {
	res, err := c.sendCategoryList(ctx)
	return res, err
}

func (c *Client) sendCategoryList(ctx context.Context) (res []CategoryTag, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tag/category"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCategoryListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangeProjectIcon invokes changeProjectIcon operation.
//
// The new icon may be up to 256KiB in size.
//
// PATCH /project/{id|slug}/icon
func (c *Client) ChangeProjectIcon(ctx context.Context, request ChangeProjectIconReq, params ChangeProjectIconParams) (ChangeProjectIconRes, error) {
	res, err := c.sendChangeProjectIcon(ctx, request, params)
	return res, err
}

func (c *Client) sendChangeProjectIcon(ctx context.Context, request ChangeProjectIconReq, params ChangeProjectIconParams) (res ChangeProjectIconRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/icon"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ext" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ext",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Ext)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeProjectIconRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ChangeProjectIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangeProjectIconResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChangeUserIcon invokes changeUserIcon operation.
//
// The new avatar may be up to 2MiB in size.
//
// PATCH /user/{id|username}/icon
func (c *Client) ChangeUserIcon(ctx context.Context, request ChangeUserIconReq, params ChangeUserIconParams) (ChangeUserIconRes, error) {
	res, err := c.sendChangeUserIcon(ctx, request, params)
	return res, err
}

func (c *Client) sendChangeUserIcon(ctx context.Context, request ChangeUserIconReq, params ChangeUserIconParams) (res ChangeUserIconRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/icon"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeChangeUserIconRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ChangeUserIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeChangeUserIconResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CheckProjectValidity invokes checkProjectValidity operation.
//
// Check project slug/ID validity.
//
// GET /project/{id|slug}/check
func (c *Client) CheckProjectValidity(ctx context.Context, params CheckProjectValidityParams) (CheckProjectValidityRes, error) {
	res, err := c.sendCheckProjectValidity(ctx, params)
	return res, err
}

func (c *Client) sendCheckProjectValidity(ctx context.Context, params CheckProjectValidityParams) (res CheckProjectValidityRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/check"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCheckProjectValidityResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// CreateVersion invokes createVersion operation.
//
// This route creates a version on an existing project. There must be at least one file attached to
// each new version, unless the new version's status is `draft`. `.mrpack`, `.jar`, `.zip`, and `.
// litemod` files are accepted.
// The request is a [multipart request](https://www.ietf.org/rfc/rfc2388.txt) with at least two form
// fields: one is `data`, which includes a JSON body with the version metadata as shown below, and at
// least one field containing an upload file.
// You can name the file parts anything you would like, but you must list each of the parts' names in
// `file_parts`, and optionally, provide one to use as the primary file in `primary_file`.
//
// POST /version
func (c *Client) CreateVersion(ctx context.Context, request OptCreateVersionBodyMultipart) (CreateVersionRes, error) {
	res, err := c.sendCreateVersion(ctx, request)
	return res, err
}

func (c *Client) sendCreateVersion(ctx context.Context, request OptCreateVersionBodyMultipart) (res CreateVersionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/version"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeCreateVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, CreateVersionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeCreateVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteFileFromHash invokes deleteFileFromHash operation.
//
// Delete a file from its hash.
//
// DELETE /version_file/{hash}
func (c *Client) DeleteFileFromHash(ctx context.Context, params DeleteFileFromHashParams) (DeleteFileFromHashRes, error) {
	res, err := c.sendDeleteFileFromHash(ctx, params)
	return res, err
}

func (c *Client) sendDeleteFileFromHash(ctx context.Context, params DeleteFileFromHashParams) (res DeleteFileFromHashRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/version_file/"
	{
		// Encode "hash" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hash",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Hash))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "version_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "version_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.VersionID.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "algorithm" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "algorithm",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Algorithm)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, DeleteFileFromHashOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteFileFromHashResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteGalleryImage invokes deleteGalleryImage operation.
//
// Delete a gallery image.
//
// DELETE /project/{id|slug}/gallery
func (c *Client) DeleteGalleryImage(ctx context.Context, params DeleteGalleryImageParams) (DeleteGalleryImageRes, error) {
	res, err := c.sendDeleteGalleryImage(ctx, params)
	return res, err
}

func (c *Client) sendDeleteGalleryImage(ctx context.Context, params DeleteGalleryImageParams) (res DeleteGalleryImageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/gallery"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "url" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.URLToString(params.URL))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, DeleteGalleryImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteGalleryImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteNotification invokes deleteNotification operation.
//
// Delete notification.
//
// DELETE /notification/{id}
func (c *Client) DeleteNotification(ctx context.Context, params DeleteNotificationParams) (DeleteNotificationRes, error) {
	res, err := c.sendDeleteNotification(ctx, params)
	return res, err
}

func (c *Client) sendDeleteNotification(ctx context.Context, params DeleteNotificationParams) (res DeleteNotificationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/notification/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, DeleteNotificationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNotificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteNotifications invokes deleteNotifications operation.
//
// Delete multiple notifications.
//
// DELETE /notifications
func (c *Client) DeleteNotifications(ctx context.Context, params DeleteNotificationsParams) (DeleteNotificationsRes, error) {
	res, err := c.sendDeleteNotifications(ctx, params)
	return res, err
}

func (c *Client) sendDeleteNotifications(ctx context.Context, params DeleteNotificationsParams) (res DeleteNotificationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, DeleteNotificationsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteNotificationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProject invokes deleteProject operation.
//
// Delete a project.
//
// DELETE /project/{id|slug}
func (c *Client) DeleteProject(ctx context.Context, params DeleteProjectParams) (DeleteProjectRes, error) {
	res, err := c.sendDeleteProject(ctx, params)
	return res, err
}

func (c *Client) sendDeleteProject(ctx context.Context, params DeleteProjectParams) (res DeleteProjectRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, DeleteProjectOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteProjectIcon invokes deleteProjectIcon operation.
//
// Delete project's icon.
//
// DELETE /project/{id|slug}/icon
func (c *Client) DeleteProjectIcon(ctx context.Context, params DeleteProjectIconParams) (DeleteProjectIconRes, error) {
	res, err := c.sendDeleteProjectIcon(ctx, params)
	return res, err
}

func (c *Client) sendDeleteProjectIcon(ctx context.Context, params DeleteProjectIconParams) (res DeleteProjectIconRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/icon"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, DeleteProjectIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteProjectIconResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteTeamMember invokes deleteTeamMember operation.
//
// Remove a member from a team.
//
// DELETE /team/{id}/members/{id|username}
func (c *Client) DeleteTeamMember(ctx context.Context, params DeleteTeamMemberParams) (DeleteTeamMemberRes, error) {
	res, err := c.sendDeleteTeamMember(ctx, params)
	return res, err
}

func (c *Client) sendDeleteTeamMember(ctx context.Context, params DeleteTeamMemberParams) (res DeleteTeamMemberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/team/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, DeleteTeamMemberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteTeamMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteThreadMessage invokes deleteThreadMessage operation.
//
// Delete a thread message.
//
// DELETE /message/{id}
func (c *Client) DeleteThreadMessage(ctx context.Context, params DeleteThreadMessageParams) (DeleteThreadMessageRes, error) {
	res, err := c.sendDeleteThreadMessage(ctx, params)
	return res, err
}

func (c *Client) sendDeleteThreadMessage(ctx context.Context, params DeleteThreadMessageParams) (res DeleteThreadMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/message/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, DeleteThreadMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteThreadMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteUserIcon invokes deleteUserIcon operation.
//
// Remove user's avatar.
//
// DELETE /user/{id|username}/icon
func (c *Client) DeleteUserIcon(ctx context.Context, params DeleteUserIconParams) (DeleteUserIconRes, error) {
	res, err := c.sendDeleteUserIcon(ctx, params)
	return res, err
}

func (c *Client) sendDeleteUserIcon(ctx context.Context, params DeleteUserIconParams) (res DeleteUserIconRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/icon"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, DeleteUserIconOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteUserIconResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DeleteVersion invokes deleteVersion operation.
//
// Delete a version.
//
// DELETE /version/{id}
func (c *Client) DeleteVersion(ctx context.Context, params DeleteVersionParams) (DeleteVersionRes, error) {
	res, err := c.sendDeleteVersion(ctx, params)
	return res, err
}

func (c *Client) sendDeleteVersion(ctx context.Context, params DeleteVersionParams) (res DeleteVersionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/version/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, DeleteVersionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDeleteVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// DonationPlatformList invokes donationPlatformList operation.
//
// Gets an array of donation platforms and information about them.
//
// GET /tag/donation_platform
func (c *Client) DonationPlatformList(ctx context.Context) ([]DonationPlatformTag, error) {
	res, err := c.sendDonationPlatformList(ctx)
	return res, err
}

func (c *Client) sendDonationPlatformList(ctx context.Context) (res []DonationPlatformTag, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tag/donation_platform"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeDonationPlatformListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FollowProject invokes followProject operation.
//
// Follow a project.
//
// POST /project/{id|slug}/follow
func (c *Client) FollowProject(ctx context.Context, params FollowProjectParams) (FollowProjectRes, error) {
	res, err := c.sendFollowProject(ctx, params)
	return res, err
}

func (c *Client) sendFollowProject(ctx context.Context, params FollowProjectParams) (res FollowProjectRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/follow"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, FollowProjectOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeFollowProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ForgeUpdates invokes forgeUpdates operation.
//
// If you're a Forge mod developer, your Modrinth mods have an automatically generated `updates.json`
// using the
// [Forge Update Checker](https://docs.minecraftforge.net/en/latest/misc/updatechecker/).
// The only setup is to insert the URL into the `[[mods]]` section of your `mods.toml` file as such:
// ```toml
// [[mods]]
// # the other stuff here - ID, version, display name, etc.
// updateJSONURL = "https://api.modrinth.com/updates/{slug|ID}/forge_updates.json"
// ```
// Replace `{slug|id}` with the slug or ID of your project.
// Modrinth will handle the rest! When you update your mod, Forge will notify your users that their
// copy of your mod is out of date.
// Make sure that the version format you use for your Modrinth releases is the same as the version
// format you use in your `mods.toml`.
// If you use a format such as `1.2.3-forge` or `1.2.3+1.19` with your Modrinth releases but your
// `mods.toml` only has `1.2.3`,
// the update checker may not function properly.
//
// GET /updates/{id|slug}/forge_updates.json
func (c *Client) ForgeUpdates(ctx context.Context, params ForgeUpdatesParams) (ForgeUpdatesRes, error) {
	res, err := c.sendForgeUpdates(ctx, params)
	return res, err
}

func (c *Client) sendForgeUpdates(ctx context.Context, params ForgeUpdatesParams) (res ForgeUpdatesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/updates/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/forge_updates.json"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeForgeUpdatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetDependencies invokes getDependencies operation.
//
// Get all of a project's dependencies.
//
// GET /project/{id|slug}/dependencies
func (c *Client) GetDependencies(ctx context.Context, params GetDependenciesParams) (GetDependenciesRes, error) {
	res, err := c.sendGetDependencies(ctx, params)
	return res, err
}

func (c *Client) sendGetDependencies(ctx context.Context, params GetDependenciesParams) (res GetDependenciesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/dependencies"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetDependenciesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetFollowedProjects invokes getFollowedProjects operation.
//
// Get user's followed projects.
//
// GET /user/{id|username}/follows
func (c *Client) GetFollowedProjects(ctx context.Context, params GetFollowedProjectsParams) (GetFollowedProjectsRes, error) {
	res, err := c.sendGetFollowedProjects(ctx, params)
	return res, err
}

func (c *Client) sendGetFollowedProjects(ctx context.Context, params GetFollowedProjectsParams) (res GetFollowedProjectsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/follows"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetFollowedProjectsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetFollowedProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLatestVersionFromHash invokes getLatestVersionFromHash operation.
//
// Latest version of a project from a hash, loader(s), and game version(s).
//
// POST /version_file/{hash}/update
func (c *Client) GetLatestVersionFromHash(ctx context.Context, request OptGetLatestVersionFromHashBody, params GetLatestVersionFromHashParams) (GetLatestVersionFromHashRes, error) {
	res, err := c.sendGetLatestVersionFromHash(ctx, request, params)
	return res, err
}

func (c *Client) sendGetLatestVersionFromHash(ctx context.Context, request OptGetLatestVersionFromHashBody, params GetLatestVersionFromHashParams) (res GetLatestVersionFromHashRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/version_file/"
	{
		// Encode "hash" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hash",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Hash))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/update"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "algorithm" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "algorithm",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Algorithm)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetLatestVersionFromHashRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLatestVersionFromHashResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetLatestVersionsFromHashes invokes getLatestVersionsFromHashes operation.
//
// This is the same as [`/version_file/{hash}/update`](#operation/getLatestVersionFromHash) except it
// accepts multiple hashes.
//
// POST /version_files/update
func (c *Client) GetLatestVersionsFromHashes(ctx context.Context, request OptGetLatestVersionsFromHashesBody) (GetLatestVersionsFromHashesRes, error) {
	res, err := c.sendGetLatestVersionsFromHashes(ctx, request)
	return res, err
}

func (c *Client) sendGetLatestVersionsFromHashes(ctx context.Context, request OptGetLatestVersionsFromHashesBody) (res GetLatestVersionsFromHashesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/version_files/update"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeGetLatestVersionsFromHashesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetLatestVersionsFromHashesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNotification invokes getNotification operation.
//
// Get notification from ID.
//
// GET /notification/{id}
func (c *Client) GetNotification(ctx context.Context, params GetNotificationParams) (GetNotificationRes, error) {
	res, err := c.sendGetNotification(ctx, params)
	return res, err
}

func (c *Client) sendGetNotification(ctx context.Context, params GetNotificationParams) (res GetNotificationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/notification/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetNotificationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNotificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetNotifications invokes getNotifications operation.
//
// Get multiple notifications.
//
// GET /notifications
func (c *Client) GetNotifications(ctx context.Context, params GetNotificationsParams) (GetNotificationsRes, error) {
	res, err := c.sendGetNotifications(ctx, params)
	return res, err
}

func (c *Client) sendGetNotifications(ctx context.Context, params GetNotificationsParams) (res GetNotificationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetNotificationsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetNotificationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetOpenReports invokes getOpenReports operation.
//
// Get your open reports.
//
// GET /report
func (c *Client) GetOpenReports(ctx context.Context, params GetOpenReportsParams) (GetOpenReportsRes, error) {
	res, err := c.sendGetOpenReports(ctx, params)
	return res, err
}

func (c *Client) sendGetOpenReports(ctx context.Context, params GetOpenReportsParams) (res GetOpenReportsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/report"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Count.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetOpenReportsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetOpenReportsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetPayoutHistory invokes getPayoutHistory operation.
//
// Get user's payout history.
//
// GET /user/{id|username}/payouts
func (c *Client) GetPayoutHistory(ctx context.Context, params GetPayoutHistoryParams) (GetPayoutHistoryRes, error) {
	res, err := c.sendGetPayoutHistory(ctx, params)
	return res, err
}

func (c *Client) sendGetPayoutHistory(ctx context.Context, params GetPayoutHistoryParams) (res GetPayoutHistoryRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/payouts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetPayoutHistoryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetPayoutHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProject invokes getProject operation.
//
// Get a project.
//
// GET /project/{id|slug}
func (c *Client) GetProject(ctx context.Context, params GetProjectParams) (GetProjectRes, error) {
	res, err := c.sendGetProject(ctx, params)
	return res, err
}

func (c *Client) sendGetProject(ctx context.Context, params GetProjectParams) (res GetProjectRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjectTeamMembers invokes getProjectTeamMembers operation.
//
// Get a project's team members.
//
// GET /project/{id|slug}/members
func (c *Client) GetProjectTeamMembers(ctx context.Context, params GetProjectTeamMembersParams) (GetProjectTeamMembersRes, error) {
	res, err := c.sendGetProjectTeamMembers(ctx, params)
	return res, err
}

func (c *Client) sendGetProjectTeamMembers(ctx context.Context, params GetProjectTeamMembersParams) (res GetProjectTeamMembersRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetProjectTeamMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjectVersions invokes getProjectVersions operation.
//
// List project's versions.
//
// GET /project/{id|slug}/version
func (c *Client) GetProjectVersions(ctx context.Context, params GetProjectVersionsParams) (GetProjectVersionsRes, error) {
	res, err := c.sendGetProjectVersions(ctx, params)
	return res, err
}

func (c *Client) sendGetProjectVersions(ctx context.Context, params GetProjectVersionsParams) (res GetProjectVersionsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/version"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "loaders" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "loaders",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Loaders.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "game_versions" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "game_versions",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.GameVersions.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featured" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featured",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Featured.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetProjectVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetProjects invokes getProjects operation.
//
// Get multiple projects.
//
// GET /projects
func (c *Client) GetProjects(ctx context.Context, params GetProjectsParams) ([]Project, error) {
	res, err := c.sendGetProjects(ctx, params)
	return res, err
}

func (c *Client) sendGetProjects(ctx context.Context, params GetProjectsParams) (res []Project, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetReport invokes getReport operation.
//
// Get report from ID.
//
// GET /report/{id}
func (c *Client) GetReport(ctx context.Context, params GetReportParams) (GetReportRes, error) {
	res, err := c.sendGetReport(ctx, params)
	return res, err
}

func (c *Client) sendGetReport(ctx context.Context, params GetReportParams) (res GetReportRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/report/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetReportOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetReports invokes getReports operation.
//
// Get multiple reports.
//
// GET /reports
func (c *Client) GetReports(ctx context.Context, params GetReportsParams) (GetReportsRes, error) {
	res, err := c.sendGetReports(ctx, params)
	return res, err
}

func (c *Client) sendGetReports(ctx context.Context, params GetReportsParams) (res GetReportsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/reports"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetReportsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetReportsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTeamMembers invokes getTeamMembers operation.
//
// Get a team's members.
//
// GET /team/{id}/members
func (c *Client) GetTeamMembers(ctx context.Context, params GetTeamMembersParams) ([]TeamMember, error) {
	res, err := c.sendGetTeamMembers(ctx, params)
	return res, err
}

func (c *Client) sendGetTeamMembers(ctx context.Context, params GetTeamMembersParams) (res []TeamMember, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/team/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetTeamMembersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTeamMembersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetTeams invokes getTeams operation.
//
// Get the members of multiple teams.
//
// GET /teams
func (c *Client) GetTeams(ctx context.Context, params GetTeamsParams) ([][]TeamMember, error) {
	res, err := c.sendGetTeams(ctx, params)
	return res, err
}

func (c *Client) sendGetTeams(ctx context.Context, params GetTeamsParams) (res [][]TeamMember, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/teams"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetTeamsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetThread invokes getThread operation.
//
// Get a thread.
//
// GET /thread/{id}
func (c *Client) GetThread(ctx context.Context, params GetThreadParams) (GetThreadRes, error) {
	res, err := c.sendGetThread(ctx, params)
	return res, err
}

func (c *Client) sendGetThread(ctx context.Context, params GetThreadParams) (res GetThreadRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/thread/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetThreadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetThreadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetThreads invokes getThreads operation.
//
// Get multiple threads.
//
// GET /threads
func (c *Client) GetThreads(ctx context.Context, params GetThreadsParams) (GetThreadsRes, error) {
	res, err := c.sendGetThreads(ctx, params)
	return res, err
}

func (c *Client) sendGetThreads(ctx context.Context, params GetThreadsParams) (res GetThreadsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/threads"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetThreadsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetThreadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUser invokes getUser operation.
//
// Get a user.
//
// GET /user/{id|username}
func (c *Client) GetUser(ctx context.Context, params GetUserParams) (GetUserRes, error) {
	res, err := c.sendGetUser(ctx, params)
	return res, err
}

func (c *Client) sendGetUser(ctx context.Context, params GetUserParams) (res GetUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserFromAuth invokes getUserFromAuth operation.
//
// Get user from authorization header.
//
// GET /user
func (c *Client) GetUserFromAuth(ctx context.Context) (GetUserFromAuthRes, error) {
	res, err := c.sendGetUserFromAuth(ctx)
	return res, err
}

func (c *Client) sendGetUserFromAuth(ctx context.Context) (res GetUserFromAuthRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetUserFromAuthOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserFromAuthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserNotifications invokes getUserNotifications operation.
//
// Get user's notifications.
//
// GET /user/{id|username}/notifications
func (c *Client) GetUserNotifications(ctx context.Context, params GetUserNotificationsParams) (GetUserNotificationsRes, error) {
	res, err := c.sendGetUserNotifications(ctx, params)
	return res, err
}

func (c *Client) sendGetUserNotifications(ctx context.Context, params GetUserNotificationsParams) (res GetUserNotificationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, GetUserNotificationsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserNotificationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUserProjects invokes getUserProjects operation.
//
// Get user's projects.
//
// GET /user/{id|username}/projects
func (c *Client) GetUserProjects(ctx context.Context, params GetUserProjectsParams) (GetUserProjectsRes, error) {
	res, err := c.sendGetUserProjects(ctx, params)
	return res, err
}

func (c *Client) sendGetUserProjects(ctx context.Context, params GetUserProjectsParams) (res GetUserProjectsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUserProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetUsers invokes getUsers operation.
//
// Get multiple users.
//
// GET /users
func (c *Client) GetUsers(ctx context.Context, params GetUsersParams) ([]User, error) {
	res, err := c.sendGetUsers(ctx, params)
	return res, err
}

func (c *Client) sendGetUsers(ctx context.Context, params GetUsersParams) (res []User, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVersion invokes getVersion operation.
//
// Get a version.
//
// GET /version/{id}
func (c *Client) GetVersion(ctx context.Context, params GetVersionParams) (GetVersionRes, error) {
	res, err := c.sendGetVersion(ctx, params)
	return res, err
}

func (c *Client) sendGetVersion(ctx context.Context, params GetVersionParams) (res GetVersionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/version/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVersionFromIdOrNumber invokes getVersionFromIdOrNumber operation.
//
// Please note that, if the version number provided matches multiple versions, only the **oldest
// matching version** will be returned.
//
// GET /project/{id|slug}/version/{id|number}
func (c *Client) GetVersionFromIdOrNumber(ctx context.Context, params GetVersionFromIdOrNumberParams) (GetVersionFromIdOrNumberRes, error) {
	res, err := c.sendGetVersionFromIdOrNumber(ctx, params)
	return res, err
}

func (c *Client) sendGetVersionFromIdOrNumber(ctx context.Context, params GetVersionFromIdOrNumberParams) (res GetVersionFromIdOrNumberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/version/"
	{
		// Encode "id|number" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|number",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDNumber))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVersionFromIdOrNumberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// GetVersions invokes getVersions operation.
//
// Get multiple versions.
//
// GET /versions
func (c *Client) GetVersions(ctx context.Context, params GetVersionsParams) ([]Version, error) {
	res, err := c.sendGetVersions(ctx, params)
	return res, err
}

func (c *Client) sendGetVersions(ctx context.Context, params GetVersionsParams) (res []Version, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/versions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeGetVersionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// JoinTeam invokes joinTeam operation.
//
// Join a team.
//
// POST /team/{id}/join
func (c *Client) JoinTeam(ctx context.Context, params JoinTeamParams) (JoinTeamRes, error) {
	res, err := c.sendJoinTeam(ctx, params)
	return res, err
}

func (c *Client) sendJoinTeam(ctx context.Context, params JoinTeamParams) (res JoinTeamRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/team/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/join"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, JoinTeamOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeJoinTeamResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LicenseList invokes licenseList operation.
//
// Deprecated - simply use SPDX IDs.
//
// Deprecated: schema marks this operation as deprecated.
//
// GET /tag/license
func (c *Client) LicenseList(ctx context.Context) ([]LicenseTag, error) {
	res, err := c.sendLicenseList(ctx)
	return res, err
}

func (c *Client) sendLicenseList(ctx context.Context) (res []LicenseTag, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tag/license"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLicenseListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LicenseText invokes licenseText operation.
//
// Get the text and title of a license.
//
// GET /tag/license/{id}
func (c *Client) LicenseText(ctx context.Context, params LicenseTextParams) (LicenseTextRes, error) {
	res, err := c.sendLicenseText(ctx, params)
	return res, err
}

func (c *Client) sendLicenseText(ctx context.Context, params LicenseTextParams) (res LicenseTextRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/tag/license/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLicenseTextResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// LoaderList invokes loaderList operation.
//
// Gets an array of loaders, their icons, and supported project types.
//
// GET /tag/loader
func (c *Client) LoaderList(ctx context.Context) ([]LoaderTag, error) {
	res, err := c.sendLoaderList(ctx)
	return res, err
}

func (c *Client) sendLoaderList(ctx context.Context) (res []LoaderTag, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tag/loader"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeLoaderListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ModifyGalleryImage invokes modifyGalleryImage operation.
//
// Modify a gallery image.
//
// PATCH /project/{id|slug}/gallery
func (c *Client) ModifyGalleryImage(ctx context.Context, params ModifyGalleryImageParams) (ModifyGalleryImageRes, error) {
	res, err := c.sendModifyGalleryImage(ctx, params)
	return res, err
}

func (c *Client) sendModifyGalleryImage(ctx context.Context, params ModifyGalleryImageParams) (res ModifyGalleryImageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/gallery"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "url" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "url",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.URLToString(params.URL))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "featured" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "featured",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Featured.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "title" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "title",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Title.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "description" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "description",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Description.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "ordering" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ordering",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Ordering.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ModifyGalleryImageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeModifyGalleryImageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ModifyProject invokes modifyProject operation.
//
// Modify a project.
//
// PATCH /project/{id|slug}
func (c *Client) ModifyProject(ctx context.Context, request OptEditableProject, params ModifyProjectParams) (ModifyProjectRes, error) {
	res, err := c.sendModifyProject(ctx, request, params)
	return res, err
}

func (c *Client) sendModifyProject(ctx context.Context, request OptEditableProject, params ModifyProjectParams) (res ModifyProjectRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeModifyProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ModifyProjectOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeModifyProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ModifyReport invokes modifyReport operation.
//
// Modify a report.
//
// PATCH /report/{id}
func (c *Client) ModifyReport(ctx context.Context, request OptModifyReportReq, params ModifyReportParams) (ModifyReportRes, error) {
	res, err := c.sendModifyReport(ctx, request, params)
	return res, err
}

func (c *Client) sendModifyReport(ctx context.Context, request OptModifyReportReq, params ModifyReportParams) (res ModifyReportRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/report/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeModifyReportRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ModifyReportOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeModifyReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ModifyTeamMember invokes modifyTeamMember operation.
//
// Modify a team member's information.
//
// PATCH /team/{id}/members/{id|username}
func (c *Client) ModifyTeamMember(ctx context.Context, request ModifyTeamMemberBody, params ModifyTeamMemberParams) (ModifyTeamMemberRes, error) {
	res, err := c.sendModifyTeamMember(ctx, request, params)
	return res, err
}

func (c *Client) sendModifyTeamMember(ctx context.Context, request ModifyTeamMemberBody, params ModifyTeamMemberParams) (res ModifyTeamMemberRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [4]string
	pathParts[0] = "/team/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/members/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeModifyTeamMemberRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ModifyTeamMemberOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeModifyTeamMemberResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ModifyUser invokes modifyUser operation.
//
// Modify a user.
//
// PATCH /user/{id|username}
func (c *Client) ModifyUser(ctx context.Context, request OptEditableUser, params ModifyUserParams) (ModifyUserRes, error) {
	res, err := c.sendModifyUser(ctx, request, params)
	return res, err
}

func (c *Client) sendModifyUser(ctx context.Context, request OptEditableUser, params ModifyUserParams) (res ModifyUserRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/user/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeModifyUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ModifyUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeModifyUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ModifyVersion invokes modifyVersion operation.
//
// Modify a version.
//
// PATCH /version/{id}
func (c *Client) ModifyVersion(ctx context.Context, request OptEditableVersion, params ModifyVersionParams) (ModifyVersionRes, error) {
	res, err := c.sendModifyVersion(ctx, request, params)
	return res, err
}

func (c *Client) sendModifyVersion(ctx context.Context, request OptEditableVersion, params ModifyVersionParams) (res ModifyVersionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/version/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeModifyVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ModifyVersionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeModifyVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PatchProjects invokes patchProjects operation.
//
// Bulk-edit multiple projects.
//
// PATCH /projects
func (c *Client) PatchProjects(ctx context.Context, request OptPatchProjectsBody, params PatchProjectsParams) (PatchProjectsRes, error) {
	res, err := c.sendPatchProjects(ctx, request, params)
	return res, err
}

func (c *Client) sendPatchProjects(ctx context.Context, request OptPatchProjectsBody, params PatchProjectsParams) (res PatchProjectsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/projects"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePatchProjectsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, PatchProjectsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodePatchProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectTypeList invokes projectTypeList operation.
//
// Gets an array of valid project types.
//
// GET /tag/project_type
func (c *Client) ProjectTypeList(ctx context.Context) ([]string, error) {
	res, err := c.sendProjectTypeList(ctx)
	return res, err
}

func (c *Client) sendProjectTypeList(ctx context.Context) (res []string, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tag/project_type"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectTypeListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RandomProjects invokes randomProjects operation.
//
// Get a list of random projects.
//
// GET /projects_random
func (c *Client) RandomProjects(ctx context.Context, params RandomProjectsParams) (RandomProjectsRes, error) {
	res, err := c.sendRandomProjects(ctx, params)
	return res, err
}

func (c *Client) sendRandomProjects(ctx context.Context, params RandomProjectsParams) (res RandomProjectsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/projects_random"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "count" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "count",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.IntToString(params.Count))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeRandomProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReadNotification invokes readNotification operation.
//
// Mark notification as read.
//
// PATCH /notification/{id}
func (c *Client) ReadNotification(ctx context.Context, params ReadNotificationParams) (ReadNotificationRes, error) {
	res, err := c.sendReadNotification(ctx, params)
	return res, err
}

func (c *Client) sendReadNotification(ctx context.Context, params ReadNotificationParams) (res ReadNotificationRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/notification/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ReadNotificationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReadNotificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReadNotifications invokes readNotifications operation.
//
// Mark multiple notifications as read.
//
// PATCH /notifications
func (c *Client) ReadNotifications(ctx context.Context, params ReadNotificationsParams) (ReadNotificationsRes, error) {
	res, err := c.sendReadNotifications(ctx, params)
	return res, err
}

func (c *Client) sendReadNotifications(ctx context.Context, params ReadNotificationsParams) (res ReadNotificationsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/notifications"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(params.Ids))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ReadNotificationsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReadNotificationsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ReportTypeList invokes reportTypeList operation.
//
// Gets an array of valid report types.
//
// GET /tag/report_type
func (c *Client) ReportTypeList(ctx context.Context) ([]string, error) {
	res, err := c.sendReportTypeList(ctx)
	return res, err
}

func (c *Client) sendReportTypeList(ctx context.Context) (res []string, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tag/report_type"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeReportTypeListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ScheduleProject invokes scheduleProject operation.
//
// Schedule a project.
//
// POST /project/{id|slug}/schedule
func (c *Client) ScheduleProject(ctx context.Context, request OptSchedule, params ScheduleProjectParams) (ScheduleProjectRes, error) {
	res, err := c.sendScheduleProject(ctx, request, params)
	return res, err
}

func (c *Client) sendScheduleProject(ctx context.Context, request OptSchedule, params ScheduleProjectParams) (res ScheduleProjectRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/schedule"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeScheduleProjectRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ScheduleProjectOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeScheduleProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ScheduleVersion invokes scheduleVersion operation.
//
// Schedule a version.
//
// POST /version/{id}/schedule
func (c *Client) ScheduleVersion(ctx context.Context, request OptSchedule, params ScheduleVersionParams) (ScheduleVersionRes, error) {
	res, err := c.sendScheduleVersion(ctx, request, params)
	return res, err
}

func (c *Client) sendScheduleVersion(ctx context.Context, request OptSchedule, params ScheduleVersionParams) (res ScheduleVersionRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/version/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/schedule"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeScheduleVersionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, ScheduleVersionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeScheduleVersionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SearchProjects invokes searchProjects operation.
//
// Search projects.
//
// GET /search
func (c *Client) SearchProjects(ctx context.Context, params SearchProjectsParams) (SearchProjectsRes, error) {
	res, err := c.sendSearchProjects(ctx, params)
	return res, err
}

func (c *Client) sendSearchProjects(ctx context.Context, params SearchProjectsParams) (res SearchProjectsRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/search"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "query" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "query",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Query.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "facets" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "facets",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Facets.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "index" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "index",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Index.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSearchProjectsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SendThreadMessage invokes sendThreadMessage operation.
//
// Send a text message to a thread.
//
// POST /thread/{id}
func (c *Client) SendThreadMessage(ctx context.Context, request OptThreadMessageBody, params SendThreadMessageParams) (SendThreadMessageRes, error) {
	res, err := c.sendSendThreadMessage(ctx, request, params)
	return res, err
}

func (c *Client) sendSendThreadMessage(ctx context.Context, request OptThreadMessageBody, params SendThreadMessageParams) (res SendThreadMessageRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/thread/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSendThreadMessageRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, SendThreadMessageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSendThreadMessageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SideTypeList invokes sideTypeList operation.
//
// Gets an array of valid side types.
//
// GET /tag/side_type
func (c *Client) SideTypeList(ctx context.Context) ([]string, error) {
	res, err := c.sendSideTypeList(ctx)
	return res, err
}

func (c *Client) sendSideTypeList(ctx context.Context) (res []string, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tag/side_type"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSideTypeListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// Statistics invokes statistics operation.
//
// Various statistics about this Modrinth instance.
//
// GET /statistics
func (c *Client) Statistics(ctx context.Context) (*Statistics, error) {
	res, err := c.sendStatistics(ctx)
	return res, err
}

func (c *Client) sendStatistics(ctx context.Context) (res *Statistics, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/statistics"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeStatisticsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubmitReport invokes submitReport operation.
//
// Bring a project, user, or version to the attention of the moderators by reporting it.
//
// POST /report
func (c *Client) SubmitReport(ctx context.Context, request OptCreatableReport) (SubmitReportRes, error) {
	res, err := c.sendSubmitReport(ctx, request)
	return res, err
}

func (c *Client) sendSubmitReport(ctx context.Context, request OptCreatableReport) (res SubmitReportRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/report"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubmitReportRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, SubmitReportOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeSubmitReportResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TransferTeamOwnership invokes transferTeamOwnership operation.
//
// Transfer team's ownership to another user.
//
// PATCH /team/{id}/owner
func (c *Client) TransferTeamOwnership(ctx context.Context, request UserIdentifier, params TransferTeamOwnershipParams) (TransferTeamOwnershipRes, error) {
	res, err := c.sendTransferTeamOwnership(ctx, request, params)
	return res, err
}

func (c *Client) sendTransferTeamOwnership(ctx context.Context, request UserIdentifier, params TransferTeamOwnershipParams) (res TransferTeamOwnershipRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/team/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/owner"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTransferTeamOwnershipRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, TransferTeamOwnershipOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeTransferTeamOwnershipResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UnfollowProject invokes unfollowProject operation.
//
// Unfollow a project.
//
// DELETE /project/{id|slug}/follow
func (c *Client) UnfollowProject(ctx context.Context, params UnfollowProjectParams) (UnfollowProjectRes, error) {
	res, err := c.sendUnfollowProject(ctx, params)
	return res, err
}

func (c *Client) sendUnfollowProject(ctx context.Context, params UnfollowProjectParams) (res UnfollowProjectRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/project/"
	{
		// Encode "id|slug" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|slug",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDSlug))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/follow"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, UnfollowProjectOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeUnfollowProjectResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VersionFromHash invokes versionFromHash operation.
//
// Get version from hash.
//
// GET /version_file/{hash}
func (c *Client) VersionFromHash(ctx context.Context, params VersionFromHashParams) (VersionFromHashRes, error) {
	res, err := c.sendVersionFromHash(ctx, params)
	return res, err
}

func (c *Client) sendVersionFromHash(ctx context.Context, params VersionFromHashParams) (res VersionFromHashRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/version_file/"
	{
		// Encode "hash" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "hash",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Hash))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "multiple" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "multiple",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Multiple.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "algorithm" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "algorithm",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.StringToString(string(params.Algorithm)))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeVersionFromHashResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VersionList invokes versionList operation.
//
// Gets an array of game versions and information about them.
//
// GET /tag/game_version
func (c *Client) VersionList(ctx context.Context) ([]GameVersionTag, error) {
	res, err := c.sendVersionList(ctx)
	return res, err
}

func (c *Client) sendVersionList(ctx context.Context) (res []GameVersionTag, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/tag/game_version"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeVersionListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// VersionsFromHashes invokes versionsFromHashes operation.
//
// This is the same as [`/version_file/{hash}`](#operation/versionFromHash) except it accepts
// multiple hashes.
//
// POST /version_files
func (c *Client) VersionsFromHashes(ctx context.Context, request OptHashList) (VersionsFromHashesRes, error) {
	res, err := c.sendVersionsFromHashes(ctx, request)
	return res, err
}

func (c *Client) sendVersionsFromHashes(ctx context.Context, request OptHashList) (res VersionsFromHashesRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/version_files"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeVersionsFromHashesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeVersionsFromHashesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// WithdrawPayout invokes withdrawPayout operation.
//
// Warning: certain amounts get withheld for fees. Please do not call this API endpoint without first
// acknowledging the warnings on the corresponding frontend page.
//
// POST /user/{id|username}/payouts
func (c *Client) WithdrawPayout(ctx context.Context, params WithdrawPayoutParams) (WithdrawPayoutRes, error) {
	res, err := c.sendWithdrawPayout(ctx, params)
	return res, err
}

func (c *Client) sendWithdrawPayout(ctx context.Context, params WithdrawPayoutParams) (res WithdrawPayoutRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user/"
	{
		// Encode "id|username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id|username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.IDUsername))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/payouts"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "amount" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "amount",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.IntToString(params.Amount))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityTokenAuth(ctx, WithdrawPayoutOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TokenAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeWithdrawPayoutResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
