// Code generated by ogen, DO NOT EDIT.

package client

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AuthError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfAuthError = [2]string{
	0: "error",
	1: "description",
}

// Decode decodes AuthError from json.
func (s *AuthError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAuthError) {
					name = jsonFieldsNameOfAuthError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CategoryTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CategoryTag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("icon")
		e.Str(s.Icon)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("project_type")
		e.Str(s.ProjectType)
	}
	{
		e.FieldStart("header")
		e.Str(s.Header)
	}
}

var jsonFieldsNameOfCategoryTag = [4]string{
	0: "icon",
	1: "name",
	2: "project_type",
	3: "header",
}

// Decode decodes CategoryTag from json.
func (s *CategoryTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CategoryTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "icon":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Icon = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "project_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ProjectType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_type\"")
			}
		case "header":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Header = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"header\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CategoryTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCategoryTag) {
					name = jsonFieldsNameOfCategoryTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CategoryTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CategoryTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatableReport) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatableReport) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("report_type")
		e.Str(s.ReportType)
	}
	{
		e.FieldStart("item_id")
		e.Str(s.ItemID)
	}
	{
		e.FieldStart("item_type")
		s.ItemType.Encode(e)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
}

var jsonFieldsNameOfCreatableReport = [4]string{
	0: "report_type",
	1: "item_id",
	2: "item_type",
	3: "body",
}

// Decode decodes CreatableReport from json.
func (s *CreatableReport) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatableReport to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "report_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ReportType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"report_type\"")
			}
		case "item_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ItemID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "item_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ItemType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatableReport")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatableReport) {
					name = jsonFieldsNameOfCreatableReport[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatableReport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatableReport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatableReportItemType as json.
func (s CreatableReportItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreatableReportItemType from json.
func (s *CreatableReportItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatableReportItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreatableReportItemType(v) {
	case CreatableReportItemTypeProject:
		*s = CreatableReportItemTypeProject
	case CreatableReportItemTypeUser:
		*s = CreatableReportItemTypeUser
	case CreatableReportItemTypeVersion:
		*s = CreatableReportItemTypeVersion
	default:
		*s = CreatableReportItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreatableReportItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatableReportItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreatableVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreatableVersion) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("version_number")
		e.Str(s.VersionNumber)
	}
	{
		if s.Changelog.Set {
			e.FieldStart("changelog")
			s.Changelog.Encode(e)
		}
	}
	{
		e.FieldStart("dependencies")
		e.ArrStart()
		for _, elem := range s.Dependencies {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("game_versions")
		e.ArrStart()
		for _, elem := range s.GameVersions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("version_type")
		s.VersionType.Encode(e)
	}
	{
		e.FieldStart("loaders")
		e.ArrStart()
		for _, elem := range s.Loaders {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("featured")
		e.Bool(s.Featured)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.RequestedStatus.Set {
			e.FieldStart("requested_status")
			s.RequestedStatus.Encode(e)
		}
	}
	{
		e.FieldStart("project_id")
		e.Str(s.ProjectID)
	}
	{
		e.FieldStart("file_parts")
		e.ArrStart()
		for _, elem := range s.FileParts {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		if s.PrimaryFile.Set {
			e.FieldStart("primary_file")
			s.PrimaryFile.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreatableVersion = [13]string{
	0:  "name",
	1:  "version_number",
	2:  "changelog",
	3:  "dependencies",
	4:  "game_versions",
	5:  "version_type",
	6:  "loaders",
	7:  "featured",
	8:  "status",
	9:  "requested_status",
	10: "project_id",
	11: "file_parts",
	12: "primary_file",
}

// Decode decodes CreatableVersion from json.
func (s *CreatableVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatableVersion to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version_number":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VersionNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_number\"")
			}
		case "changelog":
			if err := func() error {
				s.Changelog.Reset()
				if err := s.Changelog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changelog\"")
			}
		case "dependencies":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Dependencies = make([]VersionDependency, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VersionDependency
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Dependencies = append(s.Dependencies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependencies\"")
			}
		case "game_versions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.GameVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.GameVersions = append(s.GameVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_versions\"")
			}
		case "version_type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.VersionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_type\"")
			}
		case "loaders":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Loaders = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Loaders = append(s.Loaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loaders\"")
			}
		case "featured":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Featured = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "requested_status":
			if err := func() error {
				s.RequestedStatus.Reset()
				if err := s.RequestedStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_status\"")
			}
		case "project_id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "file_parts":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.FileParts = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.FileParts = append(s.FileParts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_parts\"")
			}
		case "primary_file":
			if err := func() error {
				s.PrimaryFile.Reset()
				if err := s.PrimaryFile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary_file\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreatableVersion")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111011,
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreatableVersion) {
					name = jsonFieldsNameOfCreatableVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreatableVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatableVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatableVersionRequestedStatus as json.
func (s CreatableVersionRequestedStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreatableVersionRequestedStatus from json.
func (s *CreatableVersionRequestedStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatableVersionRequestedStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreatableVersionRequestedStatus(v) {
	case CreatableVersionRequestedStatusListed:
		*s = CreatableVersionRequestedStatusListed
	case CreatableVersionRequestedStatusArchived:
		*s = CreatableVersionRequestedStatusArchived
	case CreatableVersionRequestedStatusDraft:
		*s = CreatableVersionRequestedStatusDraft
	case CreatableVersionRequestedStatusUnlisted:
		*s = CreatableVersionRequestedStatusUnlisted
	default:
		*s = CreatableVersionRequestedStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreatableVersionRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatableVersionRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatableVersionStatus as json.
func (s CreatableVersionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreatableVersionStatus from json.
func (s *CreatableVersionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatableVersionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreatableVersionStatus(v) {
	case CreatableVersionStatusListed:
		*s = CreatableVersionStatusListed
	case CreatableVersionStatusArchived:
		*s = CreatableVersionStatusArchived
	case CreatableVersionStatusDraft:
		*s = CreatableVersionStatusDraft
	case CreatableVersionStatusUnlisted:
		*s = CreatableVersionStatusUnlisted
	case CreatableVersionStatusScheduled:
		*s = CreatableVersionStatusScheduled
	case CreatableVersionStatusUnknown:
		*s = CreatableVersionStatusUnknown
	default:
		*s = CreatableVersionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreatableVersionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatableVersionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatableVersionVersionType as json.
func (s CreatableVersionVersionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreatableVersionVersionType from json.
func (s *CreatableVersionVersionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreatableVersionVersionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreatableVersionVersionType(v) {
	case CreatableVersionVersionTypeRelease:
		*s = CreatableVersionVersionTypeRelease
	case CreatableVersionVersionTypeBeta:
		*s = CreatableVersionVersionTypeBeta
	case CreatableVersionVersionTypeAlpha:
		*s = CreatableVersionVersionTypeAlpha
	default:
		*s = CreatableVersionVersionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreatableVersionVersionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreatableVersionVersionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DonationPlatformTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DonationPlatformTag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("short")
		e.Str(s.Short)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDonationPlatformTag = [2]string{
	0: "short",
	1: "name",
}

// Decode decodes DonationPlatformTag from json.
func (s *DonationPlatformTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DonationPlatformTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "short":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Short = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"short\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DonationPlatformTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDonationPlatformTag) {
					name = jsonFieldsNameOfDonationPlatformTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DonationPlatformTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DonationPlatformTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditableFileType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditableFileType) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("algorithm")
		e.Str(s.Algorithm)
	}
	{
		e.FieldStart("hash")
		e.Str(s.Hash)
	}
	{
		e.FieldStart("file_type")
		s.FileType.Encode(e)
	}
}

var jsonFieldsNameOfEditableFileType = [3]string{
	0: "algorithm",
	1: "hash",
	2: "file_type",
}

// Decode decodes EditableFileType from json.
func (s *EditableFileType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableFileType to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "algorithm":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Algorithm = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"algorithm\"")
			}
		case "hash":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash\"")
			}
		case "file_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FileType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditableFileType")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditableFileType) {
					name = jsonFieldsNameOfEditableFileType[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditableFileType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableFileType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableFileTypeFileType as json.
func (s EditableFileTypeFileType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditableFileTypeFileType from json.
func (s *EditableFileTypeFileType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableFileTypeFileType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditableFileTypeFileType(v) {
	case EditableFileTypeFileTypeRequiredResourcePack:
		*s = EditableFileTypeFileTypeRequiredResourcePack
	case EditableFileTypeFileTypeOptionalResourcePack:
		*s = EditableFileTypeFileTypeOptionalResourcePack
	default:
		*s = EditableFileTypeFileType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditableFileTypeFileType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableFileTypeFileType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditableProject) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditableProject) encodeFields(e *jx.Encoder) {
	{
		if s.Slug.Set {
			e.FieldStart("slug")
			s.Slug.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ClientSide.Set {
			e.FieldStart("client_side")
			s.ClientSide.Encode(e)
		}
	}
	{
		if s.ServerSide.Set {
			e.FieldStart("server_side")
			s.ServerSide.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.RequestedStatus.Set {
			e.FieldStart("requested_status")
			s.RequestedStatus.Encode(e)
		}
	}
	{
		if s.AdditionalCategories != nil {
			e.FieldStart("additional_categories")
			e.ArrStart()
			for _, elem := range s.AdditionalCategories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IssuesURL.Set {
			e.FieldStart("issues_url")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.SourceURL.Set {
			e.FieldStart("source_url")
			s.SourceURL.Encode(e)
		}
	}
	{
		if s.WikiURL.Set {
			e.FieldStart("wiki_url")
			s.WikiURL.Encode(e)
		}
	}
	{
		if s.DiscordURL.Set {
			e.FieldStart("discord_url")
			s.DiscordURL.Encode(e)
		}
	}
	{
		if s.DonationUrls != nil {
			e.FieldStart("donation_urls")
			e.ArrStart()
			for _, elem := range s.DonationUrls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LicenseID.Set {
			e.FieldStart("license_id")
			s.LicenseID.Encode(e)
		}
	}
	{
		if s.LicenseURL.Set {
			e.FieldStart("license_url")
			s.LicenseURL.Encode(e)
		}
	}
	{
		if s.ModerationMessage.Set {
			e.FieldStart("moderation_message")
			s.ModerationMessage.Encode(e)
		}
	}
	{
		if s.ModerationMessageBody.Set {
			e.FieldStart("moderation_message_body")
			s.ModerationMessageBody.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditableProject = [19]string{
	0:  "slug",
	1:  "title",
	2:  "description",
	3:  "categories",
	4:  "client_side",
	5:  "server_side",
	6:  "body",
	7:  "status",
	8:  "requested_status",
	9:  "additional_categories",
	10: "issues_url",
	11: "source_url",
	12: "wiki_url",
	13: "discord_url",
	14: "donation_urls",
	15: "license_id",
	16: "license_url",
	17: "moderation_message",
	18: "moderation_message_body",
}

// Decode decodes EditableProject from json.
func (s *EditableProject) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableProject to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slug":
			if err := func() error {
				s.Slug.Reset()
				if err := s.Slug.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "client_side":
			if err := func() error {
				s.ClientSide.Reset()
				if err := s.ClientSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_side\"")
			}
		case "server_side":
			if err := func() error {
				s.ServerSide.Reset()
				if err := s.ServerSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_side\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "requested_status":
			if err := func() error {
				s.RequestedStatus.Reset()
				if err := s.RequestedStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_status\"")
			}
		case "additional_categories":
			if err := func() error {
				s.AdditionalCategories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdditionalCategories = append(s.AdditionalCategories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additional_categories\"")
			}
		case "issues_url":
			if err := func() error {
				s.IssuesURL.Reset()
				if err := s.IssuesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "source_url":
			if err := func() error {
				s.SourceURL.Reset()
				if err := s.SourceURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_url\"")
			}
		case "wiki_url":
			if err := func() error {
				s.WikiURL.Reset()
				if err := s.WikiURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wiki_url\"")
			}
		case "discord_url":
			if err := func() error {
				s.DiscordURL.Reset()
				if err := s.DiscordURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discord_url\"")
			}
		case "donation_urls":
			if err := func() error {
				s.DonationUrls = make([]ProjectDonationURL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectDonationURL
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DonationUrls = append(s.DonationUrls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"donation_urls\"")
			}
		case "license_id":
			if err := func() error {
				s.LicenseID.Reset()
				if err := s.LicenseID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license_id\"")
			}
		case "license_url":
			if err := func() error {
				s.LicenseURL.Reset()
				if err := s.LicenseURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license_url\"")
			}
		case "moderation_message":
			if err := func() error {
				s.ModerationMessage.Reset()
				if err := s.ModerationMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderation_message\"")
			}
		case "moderation_message_body":
			if err := func() error {
				s.ModerationMessageBody.Reset()
				if err := s.ModerationMessageBody.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderation_message_body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditableProject")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditableProject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableProject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableProjectClientSide as json.
func (s EditableProjectClientSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditableProjectClientSide from json.
func (s *EditableProjectClientSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableProjectClientSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditableProjectClientSide(v) {
	case EditableProjectClientSideRequired:
		*s = EditableProjectClientSideRequired
	case EditableProjectClientSideOptional:
		*s = EditableProjectClientSideOptional
	case EditableProjectClientSideUnsupported:
		*s = EditableProjectClientSideUnsupported
	case EditableProjectClientSideUnknown:
		*s = EditableProjectClientSideUnknown
	default:
		*s = EditableProjectClientSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditableProjectClientSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableProjectClientSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableProjectRequestedStatus as json.
func (s EditableProjectRequestedStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditableProjectRequestedStatus from json.
func (s *EditableProjectRequestedStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableProjectRequestedStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditableProjectRequestedStatus(v) {
	case EditableProjectRequestedStatusApproved:
		*s = EditableProjectRequestedStatusApproved
	case EditableProjectRequestedStatusArchived:
		*s = EditableProjectRequestedStatusArchived
	case EditableProjectRequestedStatusUnlisted:
		*s = EditableProjectRequestedStatusUnlisted
	case EditableProjectRequestedStatusPrivate:
		*s = EditableProjectRequestedStatusPrivate
	case EditableProjectRequestedStatusDraft:
		*s = EditableProjectRequestedStatusDraft
	default:
		*s = EditableProjectRequestedStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditableProjectRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableProjectRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableProjectServerSide as json.
func (s EditableProjectServerSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditableProjectServerSide from json.
func (s *EditableProjectServerSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableProjectServerSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditableProjectServerSide(v) {
	case EditableProjectServerSideRequired:
		*s = EditableProjectServerSideRequired
	case EditableProjectServerSideOptional:
		*s = EditableProjectServerSideOptional
	case EditableProjectServerSideUnsupported:
		*s = EditableProjectServerSideUnsupported
	case EditableProjectServerSideUnknown:
		*s = EditableProjectServerSideUnknown
	default:
		*s = EditableProjectServerSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditableProjectServerSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableProjectServerSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableProjectStatus as json.
func (s EditableProjectStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditableProjectStatus from json.
func (s *EditableProjectStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableProjectStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditableProjectStatus(v) {
	case EditableProjectStatusApproved:
		*s = EditableProjectStatusApproved
	case EditableProjectStatusArchived:
		*s = EditableProjectStatusArchived
	case EditableProjectStatusRejected:
		*s = EditableProjectStatusRejected
	case EditableProjectStatusDraft:
		*s = EditableProjectStatusDraft
	case EditableProjectStatusUnlisted:
		*s = EditableProjectStatusUnlisted
	case EditableProjectStatusProcessing:
		*s = EditableProjectStatusProcessing
	case EditableProjectStatusWithheld:
		*s = EditableProjectStatusWithheld
	case EditableProjectStatusScheduled:
		*s = EditableProjectStatusScheduled
	case EditableProjectStatusPrivate:
		*s = EditableProjectStatusPrivate
	case EditableProjectStatusUnknown:
		*s = EditableProjectStatusUnknown
	default:
		*s = EditableProjectStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditableProjectStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableProjectStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditableUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditableUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.PayoutData.Set {
			e.FieldStart("payout_data")
			s.PayoutData.Encode(e)
		}
	}
}

var jsonFieldsNameOfEditableUser = [5]string{
	0: "username",
	1: "name",
	2: "email",
	3: "bio",
	4: "payout_data",
}

// Decode decodes EditableUser from json.
func (s *EditableUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableUser to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "payout_data":
			if err := func() error {
				s.PayoutData.Reset()
				if err := s.PayoutData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payout_data\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditableUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEditableUser) {
					name = jsonFieldsNameOfEditableUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditableUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EditableVersion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EditableVersion) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.VersionNumber.Set {
			e.FieldStart("version_number")
			s.VersionNumber.Encode(e)
		}
	}
	{
		if s.Changelog.Set {
			e.FieldStart("changelog")
			s.Changelog.Encode(e)
		}
	}
	{
		if s.Dependencies != nil {
			e.FieldStart("dependencies")
			e.ArrStart()
			for _, elem := range s.Dependencies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.GameVersions != nil {
			e.FieldStart("game_versions")
			e.ArrStart()
			for _, elem := range s.GameVersions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.VersionType.Set {
			e.FieldStart("version_type")
			s.VersionType.Encode(e)
		}
	}
	{
		if s.Loaders != nil {
			e.FieldStart("loaders")
			e.ArrStart()
			for _, elem := range s.Loaders {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Featured.Set {
			e.FieldStart("featured")
			s.Featured.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.RequestedStatus.Set {
			e.FieldStart("requested_status")
			s.RequestedStatus.Encode(e)
		}
	}
	{
		if s.PrimaryFile != nil {
			e.FieldStart("primary_file")
			e.ArrStart()
			for _, elem := range s.PrimaryFile {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FileTypes != nil {
			e.FieldStart("file_types")
			e.ArrStart()
			for _, elem := range s.FileTypes {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEditableVersion = [12]string{
	0:  "name",
	1:  "version_number",
	2:  "changelog",
	3:  "dependencies",
	4:  "game_versions",
	5:  "version_type",
	6:  "loaders",
	7:  "featured",
	8:  "status",
	9:  "requested_status",
	10: "primary_file",
	11: "file_types",
}

// Decode decodes EditableVersion from json.
func (s *EditableVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableVersion to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version_number":
			if err := func() error {
				s.VersionNumber.Reset()
				if err := s.VersionNumber.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_number\"")
			}
		case "changelog":
			if err := func() error {
				s.Changelog.Reset()
				if err := s.Changelog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changelog\"")
			}
		case "dependencies":
			if err := func() error {
				s.Dependencies = make([]VersionDependency, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VersionDependency
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Dependencies = append(s.Dependencies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependencies\"")
			}
		case "game_versions":
			if err := func() error {
				s.GameVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.GameVersions = append(s.GameVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_versions\"")
			}
		case "version_type":
			if err := func() error {
				s.VersionType.Reset()
				if err := s.VersionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_type\"")
			}
		case "loaders":
			if err := func() error {
				s.Loaders = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Loaders = append(s.Loaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loaders\"")
			}
		case "featured":
			if err := func() error {
				s.Featured.Reset()
				if err := s.Featured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "requested_status":
			if err := func() error {
				s.RequestedStatus.Reset()
				if err := s.RequestedStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_status\"")
			}
		case "primary_file":
			if err := func() error {
				s.PrimaryFile = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.PrimaryFile = append(s.PrimaryFile, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary_file\"")
			}
		case "file_types":
			if err := func() error {
				s.FileTypes = make([]EditableFileType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EditableFileType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.FileTypes = append(s.FileTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_types\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EditableVersion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EditableVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableVersionRequestedStatus as json.
func (s EditableVersionRequestedStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditableVersionRequestedStatus from json.
func (s *EditableVersionRequestedStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableVersionRequestedStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditableVersionRequestedStatus(v) {
	case EditableVersionRequestedStatusListed:
		*s = EditableVersionRequestedStatusListed
	case EditableVersionRequestedStatusArchived:
		*s = EditableVersionRequestedStatusArchived
	case EditableVersionRequestedStatusDraft:
		*s = EditableVersionRequestedStatusDraft
	case EditableVersionRequestedStatusUnlisted:
		*s = EditableVersionRequestedStatusUnlisted
	default:
		*s = EditableVersionRequestedStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditableVersionRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableVersionRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableVersionStatus as json.
func (s EditableVersionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditableVersionStatus from json.
func (s *EditableVersionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableVersionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditableVersionStatus(v) {
	case EditableVersionStatusListed:
		*s = EditableVersionStatusListed
	case EditableVersionStatusArchived:
		*s = EditableVersionStatusArchived
	case EditableVersionStatusDraft:
		*s = EditableVersionStatusDraft
	case EditableVersionStatusUnlisted:
		*s = EditableVersionStatusUnlisted
	case EditableVersionStatusScheduled:
		*s = EditableVersionStatusScheduled
	case EditableVersionStatusUnknown:
		*s = EditableVersionStatusUnknown
	default:
		*s = EditableVersionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditableVersionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableVersionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableVersionVersionType as json.
func (s EditableVersionVersionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EditableVersionVersionType from json.
func (s *EditableVersionVersionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EditableVersionVersionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EditableVersionVersionType(v) {
	case EditableVersionVersionTypeRelease:
		*s = EditableVersionVersionTypeRelease
	case EditableVersionVersionTypeBeta:
		*s = EditableVersionVersionTypeBeta
	case EditableVersionVersionTypeAlpha:
		*s = EditableVersionVersionTypeAlpha
	default:
		*s = EditableVersionVersionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EditableVersionVersionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EditableVersionVersionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForgeUpdateCheckerPromos) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForgeUpdateCheckerPromos) encodeFields(e *jx.Encoder) {
	{
		if s.VersionMinusRecommended.Set {
			e.FieldStart("{version}-recommended")
			s.VersionMinusRecommended.Encode(e)
		}
	}
	{
		if s.VersionMinusLatest.Set {
			e.FieldStart("{version}-latest")
			s.VersionMinusLatest.Encode(e)
		}
	}
}

var jsonFieldsNameOfForgeUpdateCheckerPromos = [2]string{
	0: "{version}-recommended",
	1: "{version}-latest",
}

// Decode decodes ForgeUpdateCheckerPromos from json.
func (s *ForgeUpdateCheckerPromos) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForgeUpdateCheckerPromos to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "{version}-recommended":
			if err := func() error {
				s.VersionMinusRecommended.Reset()
				if err := s.VersionMinusRecommended.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"{version}-recommended\"")
			}
		case "{version}-latest":
			if err := func() error {
				s.VersionMinusLatest.Reset()
				if err := s.VersionMinusLatest.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"{version}-latest\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForgeUpdateCheckerPromos")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForgeUpdateCheckerPromos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForgeUpdateCheckerPromos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ForgeUpdates) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ForgeUpdates) encodeFields(e *jx.Encoder) {
	{
		if s.Homepage.Set {
			e.FieldStart("homepage")
			s.Homepage.Encode(e)
		}
	}
	{
		if s.Promos.Set {
			e.FieldStart("promos")
			s.Promos.Encode(e)
		}
	}
}

var jsonFieldsNameOfForgeUpdates = [2]string{
	0: "homepage",
	1: "promos",
}

// Decode decodes ForgeUpdates from json.
func (s *ForgeUpdates) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForgeUpdates to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "homepage":
			if err := func() error {
				s.Homepage.Reset()
				if err := s.Homepage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"homepage\"")
			}
		case "promos":
			if err := func() error {
				s.Promos.Reset()
				if err := s.Promos.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"promos\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ForgeUpdates")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ForgeUpdates) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForgeUpdates) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GalleryImage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GalleryImage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("featured")
		e.Bool(s.Featured)
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("created")
		e.Str(s.Created)
	}
	{
		if s.Ordering.Set {
			e.FieldStart("ordering")
			s.Ordering.Encode(e)
		}
	}
}

var jsonFieldsNameOfGalleryImage = [6]string{
	0: "url",
	1: "featured",
	2: "title",
	3: "description",
	4: "created",
	5: "ordering",
}

// Decode decodes GalleryImage from json.
func (s *GalleryImage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GalleryImage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "featured":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.Featured = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "created":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Created = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "ordering":
			if err := func() error {
				s.Ordering.Reset()
				if err := s.Ordering.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordering\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GalleryImage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGalleryImage) {
					name = jsonFieldsNameOfGalleryImage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GalleryImage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GalleryImage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GameVersionTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GameVersionTag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		e.Str(s.Version)
	}
	{
		e.FieldStart("version_type")
		s.VersionType.Encode(e)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
	{
		e.FieldStart("major")
		e.Bool(s.Major)
	}
}

var jsonFieldsNameOfGameVersionTag = [4]string{
	0: "version",
	1: "version_type",
	2: "date",
	3: "major",
}

// Decode decodes GameVersionTag from json.
func (s *GameVersionTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GameVersionTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "version_type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.VersionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_type\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "major":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Major = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"major\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GameVersionTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGameVersionTag) {
					name = jsonFieldsNameOfGameVersionTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GameVersionTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GameVersionTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GameVersionTagVersionType as json.
func (s GameVersionTagVersionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GameVersionTagVersionType from json.
func (s *GameVersionTagVersionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GameVersionTagVersionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GameVersionTagVersionType(v) {
	case GameVersionTagVersionTypeRelease:
		*s = GameVersionTagVersionTypeRelease
	case GameVersionTagVersionTypeSnapshot:
		*s = GameVersionTagVersionTypeSnapshot
	case GameVersionTagVersionTypeAlpha:
		*s = GameVersionTagVersionTypeAlpha
	case GameVersionTagVersionTypeBeta:
		*s = GameVersionTagVersionTypeBeta
	default:
		*s = GameVersionTagVersionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GameVersionTagVersionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GameVersionTagVersionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetFollowedProjectsOKApplicationJSON as json.
func (s GetFollowedProjectsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Project(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetFollowedProjectsOKApplicationJSON from json.
func (s *GetFollowedProjectsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetFollowedProjectsOKApplicationJSON to nil")
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = make([]Project, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetFollowedProjectsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetFollowedProjectsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetFollowedProjectsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetLatestVersionFromHashBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetLatestVersionFromHashBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("loaders")
		e.ArrStart()
		for _, elem := range s.Loaders {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("game_versions")
		e.ArrStart()
		for _, elem := range s.GameVersions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetLatestVersionFromHashBody = [2]string{
	0: "loaders",
	1: "game_versions",
}

// Decode decodes GetLatestVersionFromHashBody from json.
func (s *GetLatestVersionFromHashBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLatestVersionFromHashBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "loaders":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Loaders = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Loaders = append(s.Loaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loaders\"")
			}
		case "game_versions":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.GameVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.GameVersions = append(s.GameVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetLatestVersionFromHashBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetLatestVersionFromHashBody) {
					name = jsonFieldsNameOfGetLatestVersionFromHashBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLatestVersionFromHashBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLatestVersionFromHashBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetLatestVersionsFromHashesBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetLatestVersionsFromHashesBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hashes")
		e.ArrStart()
		for _, elem := range s.Hashes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("algorithm")
		s.Algorithm.Encode(e)
	}
	{
		e.FieldStart("loaders")
		e.ArrStart()
		for _, elem := range s.Loaders {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("game_versions")
		e.ArrStart()
		for _, elem := range s.GameVersions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetLatestVersionsFromHashesBody = [4]string{
	0: "hashes",
	1: "algorithm",
	2: "loaders",
	3: "game_versions",
}

// Decode decodes GetLatestVersionsFromHashesBody from json.
func (s *GetLatestVersionsFromHashesBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLatestVersionsFromHashesBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hashes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Hashes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hashes = append(s.Hashes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashes\"")
			}
		case "algorithm":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"algorithm\"")
			}
		case "loaders":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Loaders = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Loaders = append(s.Loaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loaders\"")
			}
		case "game_versions":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.GameVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.GameVersions = append(s.GameVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetLatestVersionsFromHashesBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetLatestVersionsFromHashesBody) {
					name = jsonFieldsNameOfGetLatestVersionsFromHashesBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetLatestVersionsFromHashesBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLatestVersionsFromHashesBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLatestVersionsFromHashesBodyAlgorithm as json.
func (s GetLatestVersionsFromHashesBodyAlgorithm) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetLatestVersionsFromHashesBodyAlgorithm from json.
func (s *GetLatestVersionsFromHashesBodyAlgorithm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetLatestVersionsFromHashesBodyAlgorithm to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetLatestVersionsFromHashesBodyAlgorithm(v) {
	case GetLatestVersionsFromHashesBodyAlgorithmSHA1:
		*s = GetLatestVersionsFromHashesBodyAlgorithmSHA1
	case GetLatestVersionsFromHashesBodyAlgorithmSha512:
		*s = GetLatestVersionsFromHashesBodyAlgorithmSha512
	default:
		*s = GetLatestVersionsFromHashesBodyAlgorithm(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetLatestVersionsFromHashesBodyAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetLatestVersionsFromHashesBodyAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetNotificationsOKApplicationJSON as json.
func (s GetNotificationsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Notification(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetNotificationsOKApplicationJSON from json.
func (s *GetNotificationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNotificationsOKApplicationJSON to nil")
	}
	var unwrapped []Notification
	if err := func() error {
		unwrapped = make([]Notification, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Notification
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetNotificationsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetNotificationsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNotificationsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOpenReportsOKApplicationJSON as json.
func (s GetOpenReportsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Report(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetOpenReportsOKApplicationJSON from json.
func (s *GetOpenReportsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOpenReportsOKApplicationJSON to nil")
	}
	var unwrapped []Report
	if err := func() error {
		unwrapped = make([]Report, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Report
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetOpenReportsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetOpenReportsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOpenReportsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProjectTeamMembersOKApplicationJSON as json.
func (s GetProjectTeamMembersOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []TeamMember(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetProjectTeamMembersOKApplicationJSON from json.
func (s *GetProjectTeamMembersOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectTeamMembersOKApplicationJSON to nil")
	}
	var unwrapped []TeamMember
	if err := func() error {
		unwrapped = make([]TeamMember, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem TeamMember
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProjectTeamMembersOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetProjectTeamMembersOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectTeamMembersOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetProjectVersionsOKApplicationJSON as json.
func (s GetProjectVersionsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Version(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetProjectVersionsOKApplicationJSON from json.
func (s *GetProjectVersionsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetProjectVersionsOKApplicationJSON to nil")
	}
	var unwrapped []Version
	if err := func() error {
		unwrapped = make([]Version, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Version
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetProjectVersionsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetProjectVersionsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetProjectVersionsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetReportsOKApplicationJSON as json.
func (s GetReportsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Report(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetReportsOKApplicationJSON from json.
func (s *GetReportsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetReportsOKApplicationJSON to nil")
	}
	var unwrapped []Report
	if err := func() error {
		unwrapped = make([]Report, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Report
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetReportsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetReportsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetReportsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetThreadsOKApplicationJSON as json.
func (s GetThreadsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Thread(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetThreadsOKApplicationJSON from json.
func (s *GetThreadsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetThreadsOKApplicationJSON to nil")
	}
	var unwrapped []Thread
	if err := func() error {
		unwrapped = make([]Thread, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Thread
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetThreadsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetThreadsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetThreadsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserNotificationsOKApplicationJSON as json.
func (s GetUserNotificationsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Notification(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetUserNotificationsOKApplicationJSON from json.
func (s *GetUserNotificationsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserNotificationsOKApplicationJSON to nil")
	}
	var unwrapped []Notification
	if err := func() error {
		unwrapped = make([]Notification, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Notification
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserNotificationsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserNotificationsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserNotificationsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserProjectsOKApplicationJSON as json.
func (s GetUserProjectsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Project(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetUserProjectsOKApplicationJSON from json.
func (s *GetUserProjectsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserProjectsOKApplicationJSON to nil")
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = make([]Project, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetUserProjectsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserProjectsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserProjectsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HashList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HashList) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hashes")
		e.ArrStart()
		for _, elem := range s.Hashes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("algorithm")
		s.Algorithm.Encode(e)
	}
}

var jsonFieldsNameOfHashList = [2]string{
	0: "hashes",
	1: "algorithm",
}

// Decode decodes HashList from json.
func (s *HashList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HashList to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hashes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Hashes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Hashes = append(s.Hashes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashes\"")
			}
		case "algorithm":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Algorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"algorithm\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HashList")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfHashList) {
					name = jsonFieldsNameOfHashList[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HashList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HashList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HashListAlgorithm as json.
func (s HashListAlgorithm) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes HashListAlgorithm from json.
func (s *HashListAlgorithm) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HashListAlgorithm to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch HashListAlgorithm(v) {
	case HashListAlgorithmSHA1:
		*s = HashListAlgorithmSHA1
	case HashListAlgorithmSha512:
		*s = HashListAlgorithmSha512
	default:
		*s = HashListAlgorithm(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HashListAlgorithm) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HashListAlgorithm) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s HashVersionMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s HashVersionMap) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes HashVersionMap from json.
func (s *HashVersionMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HashVersionMap to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem Version
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HashVersionMap")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s HashVersionMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HashVersionMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InvalidInputError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InvalidInputError) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("error")
		e.Str(s.Error)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
}

var jsonFieldsNameOfInvalidInputError = [2]string{
	0: "error",
	1: "description",
}

// Decode decodes InvalidInputError from json.
func (s *InvalidInputError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InvalidInputError to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Error = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InvalidInputError")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfInvalidInputError) {
					name = jsonFieldsNameOfInvalidInputError[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InvalidInputError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InvalidInputError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *License) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *License) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
}

var jsonFieldsNameOfLicense = [2]string{
	0: "title",
	1: "body",
}

// Decode decodes License from json.
func (s *License) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode License to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode License")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *License) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *License) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LicenseTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LicenseTag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("short")
		e.Str(s.Short)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfLicenseTag = [2]string{
	0: "short",
	1: "name",
}

// Decode decodes LicenseTag from json.
func (s *LicenseTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LicenseTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "short":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Short = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"short\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LicenseTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLicenseTag) {
					name = jsonFieldsNameOfLicenseTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LicenseTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LicenseTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoaderTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoaderTag) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("icon")
		e.Str(s.Icon)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("supported_project_types")
		e.ArrStart()
		for _, elem := range s.SupportedProjectTypes {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfLoaderTag = [3]string{
	0: "icon",
	1: "name",
	2: "supported_project_types",
}

// Decode decodes LoaderTag from json.
func (s *LoaderTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoaderTag to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "icon":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Icon = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "supported_project_types":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.SupportedProjectTypes = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.SupportedProjectTypes = append(s.SupportedProjectTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_project_types\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoaderTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoaderTag) {
					name = jsonFieldsNameOfLoaderTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoaderTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoaderTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModeratorMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModeratorMessage) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
}

var jsonFieldsNameOfModeratorMessage = [2]string{
	0: "message",
	1: "body",
}

// Decode decodes ModeratorMessage from json.
func (s *ModeratorMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModeratorMessage to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModeratorMessage")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModeratorMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModeratorMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ModifyReportReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ModifyReportReq) encodeFields(e *jx.Encoder) {
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Closed.Set {
			e.FieldStart("closed")
			s.Closed.Encode(e)
		}
	}
}

var jsonFieldsNameOfModifyReportReq = [2]string{
	0: "body",
	1: "closed",
}

// Decode decodes ModifyReportReq from json.
func (s *ModifyReportReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyReportReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "closed":
			if err := func() error {
				s.Closed.Reset()
				if err := s.Closed.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ModifyReportReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ModifyReportReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyReportReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModifyTeamMemberBody as json.
func (s ModifyTeamMemberBody) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes ModifyTeamMemberBody from json.
func (s *ModifyTeamMemberBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ModifyTeamMemberBody to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ModifyTeamMemberBody(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ModifyTeamMemberBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ModifyTeamMemberBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableFileTypeFileType as json.
func (o NilEditableFileTypeFileType) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditableFileTypeFileType from json.
func (o *NilEditableFileTypeFileType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilEditableFileTypeFileType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EditableFileTypeFileType
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilEditableFileTypeFileType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilEditableFileTypeFileType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GalleryImage as json.
func (o NilGalleryImage) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GalleryImage from json.
func (o *NilGalleryImage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGalleryImage to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GalleryImage
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGalleryImage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGalleryImage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Notification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Notification) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("user_id")
		e.Str(s.UserID)
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("text")
		e.Str(s.Text)
	}
	{
		e.FieldStart("link")
		e.Str(s.Link)
	}
	{
		e.FieldStart("read")
		e.Bool(s.Read)
	}
	{
		e.FieldStart("created")
		e.Str(s.Created)
	}
	{
		e.FieldStart("actions")
		e.ArrStart()
		for _, elem := range s.Actions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfNotification = [9]string{
	0: "id",
	1: "user_id",
	2: "type",
	3: "title",
	4: "text",
	5: "link",
	6: "read",
	7: "created",
	8: "actions",
}

// Decode decodes Notification from json.
func (s *Notification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Notification to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "user_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UserID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user_id\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "text":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Text = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"text\"")
			}
		case "link":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Link = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"link\"")
			}
		case "read":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.Read = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"read\"")
			}
		case "created":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Created = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "actions":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.Actions = make([]NotificationAction, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NotificationAction
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Actions = append(s.Actions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Notification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNotification) {
					name = jsonFieldsNameOfNotification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Notification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Notification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotificationAction) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotificationAction) encodeFields(e *jx.Encoder) {
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.ActionRoute != nil {
			e.FieldStart("action_route")
			e.ArrStart()
			for _, elem := range s.ActionRoute {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNotificationAction = [2]string{
	0: "title",
	1: "action_route",
}

// Decode decodes NotificationAction from json.
func (s *NotificationAction) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationAction to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "action_route":
			if err := func() error {
				s.ActionRoute = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ActionRoute = append(s.ActionRoute, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action_route\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotificationAction")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotificationAction) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationAction) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationType as json.
func (s NotificationType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotificationType from json.
func (s *NotificationType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotificationType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotificationType(v) {
	case NotificationTypeProjectUpdate:
		*s = NotificationTypeProjectUpdate
	case NotificationTypeTeamInvite:
		*s = NotificationTypeTeamInvite
	case NotificationTypeStatusChange:
		*s = NotificationTypeStatusChange
	case NotificationTypeModeratorMessage:
		*s = NotificationTypeModeratorMessage
	default:
		*s = NotificationType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotificationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotificationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatableReport as json.
func (o OptCreatableReport) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreatableReport from json.
func (o *OptCreatableReport) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreatableReport to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreatableReport) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreatableReport) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatableVersionStatus as json.
func (o OptCreatableVersionStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreatableVersionStatus from json.
func (o *OptCreatableVersionStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreatableVersionStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreatableVersionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreatableVersionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableProject as json.
func (o OptEditableProject) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EditableProject from json.
func (o *OptEditableProject) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditableProject to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditableProject) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditableProject) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableProjectClientSide as json.
func (o OptEditableProjectClientSide) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditableProjectClientSide from json.
func (o *OptEditableProjectClientSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditableProjectClientSide to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditableProjectClientSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditableProjectClientSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableProjectServerSide as json.
func (o OptEditableProjectServerSide) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditableProjectServerSide from json.
func (o *OptEditableProjectServerSide) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditableProjectServerSide to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditableProjectServerSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditableProjectServerSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableProjectStatus as json.
func (o OptEditableProjectStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditableProjectStatus from json.
func (o *OptEditableProjectStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditableProjectStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditableProjectStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditableProjectStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableUser as json.
func (o OptEditableUser) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EditableUser from json.
func (o *OptEditableUser) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditableUser to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditableUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditableUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableVersion as json.
func (o OptEditableVersion) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EditableVersion from json.
func (o *OptEditableVersion) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditableVersion to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditableVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditableVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableVersionStatus as json.
func (o OptEditableVersionStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditableVersionStatus from json.
func (o *OptEditableVersionStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditableVersionStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditableVersionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditableVersionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableVersionVersionType as json.
func (o OptEditableVersionVersionType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditableVersionVersionType from json.
func (o *OptEditableVersionVersionType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEditableVersionVersionType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEditableVersionVersionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEditableVersionVersionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForgeUpdateCheckerPromos as json.
func (o OptForgeUpdateCheckerPromos) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ForgeUpdateCheckerPromos from json.
func (o *OptForgeUpdateCheckerPromos) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptForgeUpdateCheckerPromos to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptForgeUpdateCheckerPromos) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptForgeUpdateCheckerPromos) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLatestVersionFromHashBody as json.
func (o OptGetLatestVersionFromHashBody) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetLatestVersionFromHashBody from json.
func (o *OptGetLatestVersionFromHashBody) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetLatestVersionFromHashBody to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetLatestVersionFromHashBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetLatestVersionFromHashBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetLatestVersionsFromHashesBody as json.
func (o OptGetLatestVersionsFromHashesBody) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetLatestVersionsFromHashesBody from json.
func (o *OptGetLatestVersionsFromHashesBody) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetLatestVersionsFromHashesBody to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetLatestVersionsFromHashesBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetLatestVersionsFromHashesBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes HashList as json.
func (o OptHashList) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes HashList from json.
func (o *OptHashList) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptHashList to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptHashList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptHashList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModifyReportReq as json.
func (o OptModifyReportReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ModifyReportReq from json.
func (o *OptModifyReportReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptModifyReportReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptModifyReportReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptModifyReportReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreatableVersionRequestedStatus as json.
func (o OptNilCreatableVersionRequestedStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreatableVersionRequestedStatus from json.
func (o *OptNilCreatableVersionRequestedStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreatableVersionRequestedStatus to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreatableVersionRequestedStatus
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreatableVersionRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreatableVersionRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableProjectRequestedStatus as json.
func (o OptNilEditableProjectRequestedStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditableProjectRequestedStatus from json.
func (o *OptNilEditableProjectRequestedStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEditableProjectRequestedStatus to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EditableProjectRequestedStatus
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEditableProjectRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEditableProjectRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EditableVersionRequestedStatus as json.
func (o OptNilEditableVersionRequestedStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EditableVersionRequestedStatus from json.
func (o *OptNilEditableVersionRequestedStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilEditableVersionRequestedStatus to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EditableVersionRequestedStatus
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilEditableVersionRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilEditableVersionRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ModeratorMessage as json.
func (o OptNilModeratorMessage) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ModeratorMessage from json.
func (o *OptNilModeratorMessage) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilModeratorMessage to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ModeratorMessage
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilModeratorMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilModeratorMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotificationType as json.
func (o OptNilNotificationType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NotificationType from json.
func (o *OptNilNotificationType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilNotificationType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v NotificationType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilNotificationType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilNotificationType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectRequestedStatus as json.
func (o OptNilProjectRequestedStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectRequestedStatus from json.
func (o *OptNilProjectRequestedStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilProjectRequestedStatus to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ProjectRequestedStatus
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilProjectRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilProjectRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes []string as json.
func (o OptNilStringArray) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.ArrStart()
	for _, elem := range o.Value {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes []string from json.
func (o *OptNilStringArray) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilStringArray to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v []string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make([]string, 0)
	if err := d.Arr(func(d *jx.Decoder) error {
		var elem string
		v, err := d.Str()
		elem = string(v)
		if err != nil {
			return err
		}
		o.Value = append(o.Value, elem)
		return nil
	}); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserPayoutData as json.
func (o OptNilUserPayoutData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserPayoutData from json.
func (o *OptNilUserPayoutData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUserPayoutData to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UserPayoutData
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUserPayoutData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUserPayoutData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VersionFileFileType as json.
func (o OptNilVersionFileFileType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VersionFileFileType from json.
func (o *OptNilVersionFileFileType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilVersionFileFileType to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v VersionFileFileType
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilVersionFileFileType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilVersionFileFileType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VersionRequestedStatus as json.
func (o OptNilVersionRequestedStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VersionRequestedStatus from json.
func (o *OptNilVersionRequestedStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilVersionRequestedStatus to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v VersionRequestedStatus
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilVersionRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilVersionRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes PatchProjectsBody as json.
func (o OptPatchProjectsBody) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes PatchProjectsBody from json.
func (o *OptPatchProjectsBody) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptPatchProjectsBody to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptPatchProjectsBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptPatchProjectsBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectLicense as json.
func (o OptProjectLicense) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ProjectLicense from json.
func (o *OptProjectLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectLicense to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMonetizationStatus as json.
func (o OptProjectMonetizationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectMonetizationStatus from json.
func (o *OptProjectMonetizationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectMonetizationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectMonetizationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectMonetizationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResultMonetizationStatus as json.
func (o OptProjectResultMonetizationStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ProjectResultMonetizationStatus from json.
func (o *OptProjectResultMonetizationStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptProjectResultMonetizationStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptProjectResultMonetizationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptProjectResultMonetizationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Schedule as json.
func (o OptSchedule) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes Schedule from json.
func (o *OptSchedule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSchedule to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSchedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSchedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThreadMessageBody as json.
func (o OptThreadMessageBody) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ThreadMessageBody from json.
func (o *OptThreadMessageBody) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptThreadMessageBody to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptThreadMessageBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptThreadMessageBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThreadMessageBodyNewStatus as json.
func (o OptThreadMessageBodyNewStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ThreadMessageBodyNewStatus from json.
func (o *OptThreadMessageBodyNewStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptThreadMessageBodyNewStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptThreadMessageBodyNewStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptThreadMessageBodyNewStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThreadMessageBodyOldStatus as json.
func (o OptThreadMessageBodyOldStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ThreadMessageBodyOldStatus from json.
func (o *OptThreadMessageBodyOldStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptThreadMessageBodyOldStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptThreadMessageBodyOldStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptThreadMessageBodyOldStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserPayoutDataPayoutWallet as json.
func (o OptUserPayoutDataPayoutWallet) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserPayoutDataPayoutWallet from json.
func (o *OptUserPayoutDataPayoutWallet) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserPayoutDataPayoutWallet to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserPayoutDataPayoutWallet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserPayoutDataPayoutWallet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserPayoutDataPayoutWalletType as json.
func (o OptUserPayoutDataPayoutWalletType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserPayoutDataPayoutWalletType from json.
func (o *OptUserPayoutDataPayoutWalletType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserPayoutDataPayoutWalletType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserPayoutDataPayoutWalletType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserPayoutDataPayoutWalletType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VersionStatus as json.
func (o OptVersionStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes VersionStatus from json.
func (o *OptVersionStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptVersionStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptVersionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptVersionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PatchProjectsBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PatchProjectsBody) encodeFields(e *jx.Encoder) {
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AddCategories != nil {
			e.FieldStart("add_categories")
			e.ArrStart()
			for _, elem := range s.AddCategories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoveCategories != nil {
			e.FieldStart("remove_categories")
			e.ArrStart()
			for _, elem := range s.RemoveCategories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AdditionalCategories != nil {
			e.FieldStart("additional_categories")
			e.ArrStart()
			for _, elem := range s.AdditionalCategories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AddAdditionalCategories != nil {
			e.FieldStart("add_additional_categories")
			e.ArrStart()
			for _, elem := range s.AddAdditionalCategories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoveAdditionalCategories != nil {
			e.FieldStart("remove_additional_categories")
			e.ArrStart()
			for _, elem := range s.RemoveAdditionalCategories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DonationUrls != nil {
			e.FieldStart("donation_urls")
			e.ArrStart()
			for _, elem := range s.DonationUrls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AddDonationUrls != nil {
			e.FieldStart("add_donation_urls")
			e.ArrStart()
			for _, elem := range s.AddDonationUrls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RemoveDonationUrls != nil {
			e.FieldStart("remove_donation_urls")
			e.ArrStart()
			for _, elem := range s.RemoveDonationUrls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IssuesURL.Set {
			e.FieldStart("issues_url")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.SourceURL.Set {
			e.FieldStart("source_url")
			s.SourceURL.Encode(e)
		}
	}
	{
		if s.WikiURL.Set {
			e.FieldStart("wiki_url")
			s.WikiURL.Encode(e)
		}
	}
	{
		if s.DiscordURL.Set {
			e.FieldStart("discord_url")
			s.DiscordURL.Encode(e)
		}
	}
}

var jsonFieldsNameOfPatchProjectsBody = [13]string{
	0:  "categories",
	1:  "add_categories",
	2:  "remove_categories",
	3:  "additional_categories",
	4:  "add_additional_categories",
	5:  "remove_additional_categories",
	6:  "donation_urls",
	7:  "add_donation_urls",
	8:  "remove_donation_urls",
	9:  "issues_url",
	10: "source_url",
	11: "wiki_url",
	12: "discord_url",
}

// Decode decodes PatchProjectsBody from json.
func (s *PatchProjectsBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PatchProjectsBody to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "categories":
			if err := func() error {
				s.Categories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "add_categories":
			if err := func() error {
				s.AddCategories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddCategories = append(s.AddCategories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_categories\"")
			}
		case "remove_categories":
			if err := func() error {
				s.RemoveCategories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RemoveCategories = append(s.RemoveCategories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_categories\"")
			}
		case "additional_categories":
			if err := func() error {
				s.AdditionalCategories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdditionalCategories = append(s.AdditionalCategories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additional_categories\"")
			}
		case "add_additional_categories":
			if err := func() error {
				s.AddAdditionalCategories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AddAdditionalCategories = append(s.AddAdditionalCategories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_additional_categories\"")
			}
		case "remove_additional_categories":
			if err := func() error {
				s.RemoveAdditionalCategories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.RemoveAdditionalCategories = append(s.RemoveAdditionalCategories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_additional_categories\"")
			}
		case "donation_urls":
			if err := func() error {
				s.DonationUrls = make([]ProjectDonationURL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectDonationURL
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DonationUrls = append(s.DonationUrls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"donation_urls\"")
			}
		case "add_donation_urls":
			if err := func() error {
				s.AddDonationUrls = make([]ProjectDonationURL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectDonationURL
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AddDonationUrls = append(s.AddDonationUrls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"add_donation_urls\"")
			}
		case "remove_donation_urls":
			if err := func() error {
				s.RemoveDonationUrls = make([]ProjectDonationURL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectDonationURL
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RemoveDonationUrls = append(s.RemoveDonationUrls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remove_donation_urls\"")
			}
		case "issues_url":
			if err := func() error {
				s.IssuesURL.Reset()
				if err := s.IssuesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "source_url":
			if err := func() error {
				s.SourceURL.Reset()
				if err := s.SourceURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_url\"")
			}
		case "wiki_url":
			if err := func() error {
				s.WikiURL.Reset()
				if err := s.WikiURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wiki_url\"")
			}
		case "discord_url":
			if err := func() error {
				s.DiscordURL.Reset()
				if err := s.DiscordURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discord_url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PatchProjectsBody")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PatchProjectsBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PatchProjectsBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Project) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Project) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		e.FieldStart("categories")
		e.ArrStart()
		for _, elem := range s.Categories {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("client_side")
		s.ClientSide.Encode(e)
	}
	{
		e.FieldStart("server_side")
		s.ServerSide.Encode(e)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		e.FieldStart("status")
		s.Status.Encode(e)
	}
	{
		if s.RequestedStatus.Set {
			e.FieldStart("requested_status")
			s.RequestedStatus.Encode(e)
		}
	}
	{
		if s.AdditionalCategories != nil {
			e.FieldStart("additional_categories")
			e.ArrStart()
			for _, elem := range s.AdditionalCategories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.IssuesURL.Set {
			e.FieldStart("issues_url")
			s.IssuesURL.Encode(e)
		}
	}
	{
		if s.SourceURL.Set {
			e.FieldStart("source_url")
			s.SourceURL.Encode(e)
		}
	}
	{
		if s.WikiURL.Set {
			e.FieldStart("wiki_url")
			s.WikiURL.Encode(e)
		}
	}
	{
		if s.DiscordURL.Set {
			e.FieldStart("discord_url")
			s.DiscordURL.Encode(e)
		}
	}
	{
		if s.DonationUrls != nil {
			e.FieldStart("donation_urls")
			e.ArrStart()
			for _, elem := range s.DonationUrls {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("project_type")
		s.ProjectType.Encode(e)
	}
	{
		e.FieldStart("downloads")
		e.Int(s.Downloads)
	}
	{
		if s.IconURL.Set {
			e.FieldStart("icon_url")
			s.IconURL.Encode(e)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.ThreadID.Set {
			e.FieldStart("thread_id")
			s.ThreadID.Encode(e)
		}
	}
	{
		if s.MonetizationStatus.Set {
			e.FieldStart("monetization_status")
			s.MonetizationStatus.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("team")
		e.Str(s.Team)
	}
	{
		if s.BodyURL.Set {
			e.FieldStart("body_url")
			s.BodyURL.Encode(e)
		}
	}
	{
		if s.ModeratorMessage.Set {
			e.FieldStart("moderator_message")
			s.ModeratorMessage.Encode(e)
		}
	}
	{
		e.FieldStart("published")
		e.Str(s.Published)
	}
	{
		e.FieldStart("updated")
		e.Str(s.Updated)
	}
	{
		if s.Approved.Set {
			e.FieldStart("approved")
			s.Approved.Encode(e)
		}
	}
	{
		if s.Queued.Set {
			e.FieldStart("queued")
			s.Queued.Encode(e)
		}
	}
	{
		e.FieldStart("followers")
		e.Int(s.Followers)
	}
	{
		if s.License.Set {
			e.FieldStart("license")
			s.License.Encode(e)
		}
	}
	{
		if s.Versions != nil {
			e.FieldStart("versions")
			e.ArrStart()
			for _, elem := range s.Versions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.GameVersions != nil {
			e.FieldStart("game_versions")
			e.ArrStart()
			for _, elem := range s.GameVersions {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Loaders != nil {
			e.FieldStart("loaders")
			e.ArrStart()
			for _, elem := range s.Loaders {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Gallery != nil {
			e.FieldStart("gallery")
			e.ArrStart()
			for _, elem := range s.Gallery {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProject = [35]string{
	0:  "slug",
	1:  "title",
	2:  "description",
	3:  "categories",
	4:  "client_side",
	5:  "server_side",
	6:  "body",
	7:  "status",
	8:  "requested_status",
	9:  "additional_categories",
	10: "issues_url",
	11: "source_url",
	12: "wiki_url",
	13: "discord_url",
	14: "donation_urls",
	15: "project_type",
	16: "downloads",
	17: "icon_url",
	18: "color",
	19: "thread_id",
	20: "monetization_status",
	21: "id",
	22: "team",
	23: "body_url",
	24: "moderator_message",
	25: "published",
	26: "updated",
	27: "approved",
	28: "queued",
	29: "followers",
	30: "license",
	31: "versions",
	32: "game_versions",
	33: "loaders",
	34: "gallery",
}

// Decode decodes Project from json.
func (s *Project) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Project to nil")
	}
	var requiredBitSet [5]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slug":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "categories":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Categories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "client_side":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ClientSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_side\"")
			}
		case "server_side":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ServerSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_side\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "status":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "requested_status":
			if err := func() error {
				s.RequestedStatus.Reset()
				if err := s.RequestedStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_status\"")
			}
		case "additional_categories":
			if err := func() error {
				s.AdditionalCategories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdditionalCategories = append(s.AdditionalCategories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additional_categories\"")
			}
		case "issues_url":
			if err := func() error {
				s.IssuesURL.Reset()
				if err := s.IssuesURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"issues_url\"")
			}
		case "source_url":
			if err := func() error {
				s.SourceURL.Reset()
				if err := s.SourceURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"source_url\"")
			}
		case "wiki_url":
			if err := func() error {
				s.WikiURL.Reset()
				if err := s.WikiURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wiki_url\"")
			}
		case "discord_url":
			if err := func() error {
				s.DiscordURL.Reset()
				if err := s.DiscordURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discord_url\"")
			}
		case "donation_urls":
			if err := func() error {
				s.DonationUrls = make([]ProjectDonationURL, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectDonationURL
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.DonationUrls = append(s.DonationUrls, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"donation_urls\"")
			}
		case "project_type":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.ProjectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_type\"")
			}
		case "downloads":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Downloads = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads\"")
			}
		case "icon_url":
			if err := func() error {
				s.IconURL.Reset()
				if err := s.IconURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_url\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "thread_id":
			if err := func() error {
				s.ThreadID.Reset()
				if err := s.ThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		case "monetization_status":
			if err := func() error {
				s.MonetizationStatus.Reset()
				if err := s.MonetizationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monetization_status\"")
			}
		case "id":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "team":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Team = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team\"")
			}
		case "body_url":
			if err := func() error {
				s.BodyURL.Reset()
				if err := s.BodyURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body_url\"")
			}
		case "moderator_message":
			if err := func() error {
				s.ModeratorMessage.Reset()
				if err := s.ModeratorMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"moderator_message\"")
			}
		case "published":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Published = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"published\"")
			}
		case "updated":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Updated = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updated\"")
			}
		case "approved":
			if err := func() error {
				s.Approved.Reset()
				if err := s.Approved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"approved\"")
			}
		case "queued":
			if err := func() error {
				s.Queued.Reset()
				if err := s.Queued.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"queued\"")
			}
		case "followers":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				v, err := d.Int()
				s.Followers = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"followers\"")
			}
		case "license":
			if err := func() error {
				s.License.Reset()
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "versions":
			if err := func() error {
				s.Versions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		case "game_versions":
			if err := func() error {
				s.GameVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.GameVersions = append(s.GameVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_versions\"")
			}
		case "loaders":
			if err := func() error {
				s.Loaders = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Loaders = append(s.Loaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loaders\"")
			}
		case "gallery":
			if err := func() error {
				s.Gallery = make([]NilGalleryImage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NilGalleryImage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Gallery = append(s.Gallery, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gallery\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Project")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [5]uint8{
		0b11111111,
		0b10000000,
		0b01100001,
		0b00100110,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProject) {
					name = jsonFieldsNameOfProject[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Project) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Project) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectClientSide as json.
func (s ProjectClientSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectClientSide from json.
func (s *ProjectClientSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectClientSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectClientSide(v) {
	case ProjectClientSideRequired:
		*s = ProjectClientSideRequired
	case ProjectClientSideOptional:
		*s = ProjectClientSideOptional
	case ProjectClientSideUnsupported:
		*s = ProjectClientSideUnsupported
	case ProjectClientSideUnknown:
		*s = ProjectClientSideUnknown
	default:
		*s = ProjectClientSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectClientSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectClientSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectDependencyList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectDependencyList) encodeFields(e *jx.Encoder) {
	{
		if s.Projects != nil {
			e.FieldStart("projects")
			e.ArrStart()
			for _, elem := range s.Projects {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Versions != nil {
			e.FieldStart("versions")
			e.ArrStart()
			for _, elem := range s.Versions {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfProjectDependencyList = [2]string{
	0: "projects",
	1: "versions",
}

// Decode decodes ProjectDependencyList from json.
func (s *ProjectDependencyList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectDependencyList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "projects":
			if err := func() error {
				s.Projects = make([]Project, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Project
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Projects = append(s.Projects, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projects\"")
			}
		case "versions":
			if err := func() error {
				s.Versions = make([]Version, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Version
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectDependencyList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectDependencyList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectDependencyList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectDonationURL) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectDonationURL) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Platform.Set {
			e.FieldStart("platform")
			s.Platform.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectDonationURL = [3]string{
	0: "id",
	1: "platform",
	2: "url",
}

// Decode decodes ProjectDonationURL from json.
func (s *ProjectDonationURL) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectDonationURL to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "platform":
			if err := func() error {
				s.Platform.Reset()
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectDonationURL")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectDonationURL) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectDonationURL) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectIdentifier) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectIdentifier) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectIdentifier = [1]string{
	0: "id",
}

// Decode decodes ProjectIdentifier from json.
func (s *ProjectIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectIdentifier to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectIdentifier")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectLicense) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectLicense) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectLicense = [3]string{
	0: "id",
	1: "name",
	2: "url",
}

// Decode decodes ProjectLicense from json.
func (s *ProjectLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectLicense to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectLicense")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectMonetizationStatus as json.
func (s ProjectMonetizationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectMonetizationStatus from json.
func (s *ProjectMonetizationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectMonetizationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectMonetizationStatus(v) {
	case ProjectMonetizationStatusMonetized:
		*s = ProjectMonetizationStatusMonetized
	case ProjectMonetizationStatusDemonetized:
		*s = ProjectMonetizationStatusDemonetized
	case ProjectMonetizationStatusForceDemonetized:
		*s = ProjectMonetizationStatusForceDemonetized
	default:
		*s = ProjectMonetizationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectMonetizationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectMonetizationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectProjectType as json.
func (s ProjectProjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectProjectType from json.
func (s *ProjectProjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectProjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectProjectType(v) {
	case ProjectProjectTypeMod:
		*s = ProjectProjectTypeMod
	case ProjectProjectTypeModpack:
		*s = ProjectProjectTypeModpack
	case ProjectProjectTypeResourcepack:
		*s = ProjectProjectTypeResourcepack
	case ProjectProjectTypeShader:
		*s = ProjectProjectTypeShader
	default:
		*s = ProjectProjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectProjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectProjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectRequestedStatus as json.
func (s ProjectRequestedStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectRequestedStatus from json.
func (s *ProjectRequestedStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectRequestedStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectRequestedStatus(v) {
	case ProjectRequestedStatusApproved:
		*s = ProjectRequestedStatusApproved
	case ProjectRequestedStatusArchived:
		*s = ProjectRequestedStatusArchived
	case ProjectRequestedStatusUnlisted:
		*s = ProjectRequestedStatusUnlisted
	case ProjectRequestedStatusPrivate:
		*s = ProjectRequestedStatusPrivate
	case ProjectRequestedStatusDraft:
		*s = ProjectRequestedStatusDraft
	default:
		*s = ProjectRequestedStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ProjectResult) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ProjectResult) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("slug")
		e.Str(s.Slug)
	}
	{
		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Categories != nil {
			e.FieldStart("categories")
			e.ArrStart()
			for _, elem := range s.Categories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("client_side")
		s.ClientSide.Encode(e)
	}
	{
		e.FieldStart("server_side")
		s.ServerSide.Encode(e)
	}
	{
		e.FieldStart("project_type")
		s.ProjectType.Encode(e)
	}
	{
		e.FieldStart("downloads")
		e.Int(s.Downloads)
	}
	{
		if s.IconURL.Set {
			e.FieldStart("icon_url")
			s.IconURL.Encode(e)
		}
	}
	{
		if s.Color.Set {
			e.FieldStart("color")
			s.Color.Encode(e)
		}
	}
	{
		if s.ThreadID.Set {
			e.FieldStart("thread_id")
			s.ThreadID.Encode(e)
		}
	}
	{
		if s.MonetizationStatus.Set {
			e.FieldStart("monetization_status")
			s.MonetizationStatus.Encode(e)
		}
	}
	{
		e.FieldStart("project_id")
		e.Str(s.ProjectID)
	}
	{
		e.FieldStart("author")
		e.Str(s.Author)
	}
	{
		if s.DisplayCategories != nil {
			e.FieldStart("display_categories")
			e.ArrStart()
			for _, elem := range s.DisplayCategories {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("versions")
		e.ArrStart()
		for _, elem := range s.Versions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("follows")
		e.Int(s.Follows)
	}
	{
		e.FieldStart("date_created")
		e.Str(s.DateCreated)
	}
	{
		e.FieldStart("date_modified")
		e.Str(s.DateModified)
	}
	{
		if s.LatestVersion.Set {
			e.FieldStart("latest_version")
			s.LatestVersion.Encode(e)
		}
	}
	{
		e.FieldStart("license")
		e.Str(s.License)
	}
	{
		if s.Gallery != nil {
			e.FieldStart("gallery")
			e.ArrStart()
			for _, elem := range s.Gallery {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.FeaturedGallery.Set {
			e.FieldStart("featured_gallery")
			s.FeaturedGallery.Encode(e)
		}
	}
}

var jsonFieldsNameOfProjectResult = [23]string{
	0:  "slug",
	1:  "title",
	2:  "description",
	3:  "categories",
	4:  "client_side",
	5:  "server_side",
	6:  "project_type",
	7:  "downloads",
	8:  "icon_url",
	9:  "color",
	10: "thread_id",
	11: "monetization_status",
	12: "project_id",
	13: "author",
	14: "display_categories",
	15: "versions",
	16: "follows",
	17: "date_created",
	18: "date_modified",
	19: "latest_version",
	20: "license",
	21: "gallery",
	22: "featured_gallery",
}

// Decode decodes ProjectResult from json.
func (s *ProjectResult) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResult to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "slug":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Slug = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"slug\"")
			}
		case "title":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "categories":
			if err := func() error {
				s.Categories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Categories = append(s.Categories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"categories\"")
			}
		case "client_side":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ClientSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"client_side\"")
			}
		case "server_side":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ServerSide.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server_side\"")
			}
		case "project_type":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.ProjectType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_type\"")
			}
		case "downloads":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.Downloads = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads\"")
			}
		case "icon_url":
			if err := func() error {
				s.IconURL.Reset()
				if err := s.IconURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"icon_url\"")
			}
		case "color":
			if err := func() error {
				s.Color.Reset()
				if err := s.Color.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"color\"")
			}
		case "thread_id":
			if err := func() error {
				s.ThreadID.Reset()
				if err := s.ThreadID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		case "monetization_status":
			if err := func() error {
				s.MonetizationStatus.Reset()
				if err := s.MonetizationStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"monetization_status\"")
			}
		case "project_id":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "author":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Author = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author\"")
			}
		case "display_categories":
			if err := func() error {
				s.DisplayCategories = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DisplayCategories = append(s.DisplayCategories, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"display_categories\"")
			}
		case "versions":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				s.Versions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Versions = append(s.Versions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		case "follows":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.Follows = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"follows\"")
			}
		case "date_created":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.DateCreated = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_created\"")
			}
		case "date_modified":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.DateModified = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_modified\"")
			}
		case "latest_version":
			if err := func() error {
				s.LatestVersion.Reset()
				if err := s.LatestVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"latest_version\"")
			}
		case "license":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.License = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "gallery":
			if err := func() error {
				s.Gallery = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Gallery = append(s.Gallery, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"gallery\"")
			}
		case "featured_gallery":
			if err := func() error {
				s.FeaturedGallery.Reset()
				if err := s.FeaturedGallery.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured_gallery\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ProjectResult")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11110111,
		0b10110000,
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfProjectResult) {
					name = jsonFieldsNameOfProjectResult[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectResult) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResult) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResultClientSide as json.
func (s ProjectResultClientSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectResultClientSide from json.
func (s *ProjectResultClientSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResultClientSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectResultClientSide(v) {
	case ProjectResultClientSideRequired:
		*s = ProjectResultClientSideRequired
	case ProjectResultClientSideOptional:
		*s = ProjectResultClientSideOptional
	case ProjectResultClientSideUnsupported:
		*s = ProjectResultClientSideUnsupported
	case ProjectResultClientSideUnknown:
		*s = ProjectResultClientSideUnknown
	default:
		*s = ProjectResultClientSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectResultClientSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResultClientSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResultMonetizationStatus as json.
func (s ProjectResultMonetizationStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectResultMonetizationStatus from json.
func (s *ProjectResultMonetizationStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResultMonetizationStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectResultMonetizationStatus(v) {
	case ProjectResultMonetizationStatusMonetized:
		*s = ProjectResultMonetizationStatusMonetized
	case ProjectResultMonetizationStatusDemonetized:
		*s = ProjectResultMonetizationStatusDemonetized
	case ProjectResultMonetizationStatusForceDemonetized:
		*s = ProjectResultMonetizationStatusForceDemonetized
	default:
		*s = ProjectResultMonetizationStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectResultMonetizationStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResultMonetizationStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResultProjectType as json.
func (s ProjectResultProjectType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectResultProjectType from json.
func (s *ProjectResultProjectType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResultProjectType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectResultProjectType(v) {
	case ProjectResultProjectTypeMod:
		*s = ProjectResultProjectTypeMod
	case ProjectResultProjectTypeModpack:
		*s = ProjectResultProjectTypeModpack
	case ProjectResultProjectTypeResourcepack:
		*s = ProjectResultProjectTypeResourcepack
	case ProjectResultProjectTypeShader:
		*s = ProjectResultProjectTypeShader
	default:
		*s = ProjectResultProjectType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectResultProjectType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResultProjectType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectResultServerSide as json.
func (s ProjectResultServerSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectResultServerSide from json.
func (s *ProjectResultServerSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectResultServerSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectResultServerSide(v) {
	case ProjectResultServerSideRequired:
		*s = ProjectResultServerSideRequired
	case ProjectResultServerSideOptional:
		*s = ProjectResultServerSideOptional
	case ProjectResultServerSideUnsupported:
		*s = ProjectResultServerSideUnsupported
	case ProjectResultServerSideUnknown:
		*s = ProjectResultServerSideUnknown
	default:
		*s = ProjectResultServerSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectResultServerSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectResultServerSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectServerSide as json.
func (s ProjectServerSide) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectServerSide from json.
func (s *ProjectServerSide) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectServerSide to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectServerSide(v) {
	case ProjectServerSideRequired:
		*s = ProjectServerSideRequired
	case ProjectServerSideOptional:
		*s = ProjectServerSideOptional
	case ProjectServerSideUnsupported:
		*s = ProjectServerSideUnsupported
	case ProjectServerSideUnknown:
		*s = ProjectServerSideUnknown
	default:
		*s = ProjectServerSide(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectServerSide) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectServerSide) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectStatus as json.
func (s ProjectStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ProjectStatus from json.
func (s *ProjectStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ProjectStatus(v) {
	case ProjectStatusApproved:
		*s = ProjectStatusApproved
	case ProjectStatusArchived:
		*s = ProjectStatusArchived
	case ProjectStatusRejected:
		*s = ProjectStatusRejected
	case ProjectStatusDraft:
		*s = ProjectStatusDraft
	case ProjectStatusUnlisted:
		*s = ProjectStatusUnlisted
	case ProjectStatusProcessing:
		*s = ProjectStatusProcessing
	case ProjectStatusWithheld:
		*s = ProjectStatusWithheld
	case ProjectStatusScheduled:
		*s = ProjectStatusScheduled
	case ProjectStatusPrivate:
		*s = ProjectStatusPrivate
	case ProjectStatusUnknown:
		*s = ProjectStatusUnknown
	default:
		*s = ProjectStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ProjectStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RandomProjectsOKApplicationJSON as json.
func (s RandomProjectsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []Project(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes RandomProjectsOKApplicationJSON from json.
func (s *RandomProjectsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RandomProjectsOKApplicationJSON to nil")
	}
	var unwrapped []Project
	if err := func() error {
		unwrapped = make([]Project, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem Project
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = RandomProjectsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RandomProjectsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RandomProjectsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Report) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Report) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("report_type")
		e.Str(s.ReportType)
	}
	{
		e.FieldStart("item_id")
		e.Str(s.ItemID)
	}
	{
		e.FieldStart("item_type")
		s.ItemType.Encode(e)
	}
	{
		e.FieldStart("body")
		e.Str(s.Body)
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		e.FieldStart("reporter")
		e.Str(s.Reporter)
	}
	{
		e.FieldStart("created")
		e.Str(s.Created)
	}
	{
		e.FieldStart("closed")
		e.Bool(s.Closed)
	}
	{
		e.FieldStart("thread_id")
		e.Str(s.ThreadID)
	}
}

var jsonFieldsNameOfReport = [9]string{
	0: "report_type",
	1: "item_id",
	2: "item_type",
	3: "body",
	4: "id",
	5: "reporter",
	6: "created",
	7: "closed",
	8: "thread_id",
}

// Decode decodes Report from json.
func (s *Report) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Report to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "report_type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ReportType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"report_type\"")
			}
		case "item_id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ItemID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_id\"")
			}
		case "item_type":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ItemType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"item_type\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Body = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "reporter":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Reporter = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"reporter\"")
			}
		case "created":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Created = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "closed":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Closed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"closed\"")
			}
		case "thread_id":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ThreadID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"thread_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Report")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReport) {
					name = jsonFieldsNameOfReport[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Report) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Report) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReportItemType as json.
func (s ReportItemType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ReportItemType from json.
func (s *ReportItemType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReportItemType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ReportItemType(v) {
	case ReportItemTypeProject:
		*s = ReportItemTypeProject
	case ReportItemTypeUser:
		*s = ReportItemTypeUser
	case ReportItemTypeVersion:
		*s = ReportItemTypeVersion
	default:
		*s = ReportItemType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ReportItemType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReportItemType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Schedule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Schedule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("time")
		e.Str(s.Time)
	}
	{
		e.FieldStart("requested_status")
		s.RequestedStatus.Encode(e)
	}
}

var jsonFieldsNameOfSchedule = [2]string{
	0: "time",
	1: "requested_status",
}

// Decode decodes Schedule from json.
func (s *Schedule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Schedule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "time":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Time = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"time\"")
			}
		case "requested_status":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RequestedStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Schedule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSchedule) {
					name = jsonFieldsNameOfSchedule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Schedule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Schedule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ScheduleRequestedStatus as json.
func (s ScheduleRequestedStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ScheduleRequestedStatus from json.
func (s *ScheduleRequestedStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ScheduleRequestedStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ScheduleRequestedStatus(v) {
	case ScheduleRequestedStatusApproved:
		*s = ScheduleRequestedStatusApproved
	case ScheduleRequestedStatusArchived:
		*s = ScheduleRequestedStatusArchived
	case ScheduleRequestedStatusUnlisted:
		*s = ScheduleRequestedStatusUnlisted
	case ScheduleRequestedStatusPrivate:
		*s = ScheduleRequestedStatusPrivate
	case ScheduleRequestedStatusDraft:
		*s = ScheduleRequestedStatusDraft
	default:
		*s = ScheduleRequestedStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ScheduleRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ScheduleRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SearchResults) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SearchResults) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hits")
		e.ArrStart()
		for _, elem := range s.Hits {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("offset")
		e.Int(s.Offset)
	}
	{
		e.FieldStart("limit")
		e.Int(s.Limit)
	}
	{
		e.FieldStart("total_hits")
		e.Int(s.TotalHits)
	}
}

var jsonFieldsNameOfSearchResults = [4]string{
	0: "hits",
	1: "offset",
	2: "limit",
	3: "total_hits",
}

// Decode decodes SearchResults from json.
func (s *SearchResults) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SearchResults to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hits":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Hits = make([]ProjectResult, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ProjectResult
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hits = append(s.Hits, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hits\"")
			}
		case "offset":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Offset = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"offset\"")
			}
		case "limit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.Limit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limit\"")
			}
		case "total_hits":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalHits = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total_hits\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SearchResults")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSearchResults) {
					name = jsonFieldsNameOfSearchResults[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SearchResults) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SearchResults) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Statistics) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Statistics) encodeFields(e *jx.Encoder) {
	{
		if s.Projects.Set {
			e.FieldStart("projects")
			s.Projects.Encode(e)
		}
	}
	{
		if s.Versions.Set {
			e.FieldStart("versions")
			s.Versions.Encode(e)
		}
	}
	{
		if s.Files.Set {
			e.FieldStart("files")
			s.Files.Encode(e)
		}
	}
	{
		if s.Authors.Set {
			e.FieldStart("authors")
			s.Authors.Encode(e)
		}
	}
}

var jsonFieldsNameOfStatistics = [4]string{
	0: "projects",
	1: "versions",
	2: "files",
	3: "authors",
}

// Decode decodes Statistics from json.
func (s *Statistics) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Statistics to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "projects":
			if err := func() error {
				s.Projects.Reset()
				if err := s.Projects.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projects\"")
			}
		case "versions":
			if err := func() error {
				s.Versions.Reset()
				if err := s.Versions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"versions\"")
			}
		case "files":
			if err := func() error {
				s.Files.Reset()
				if err := s.Files.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		case "authors":
			if err := func() error {
				s.Authors.Reset()
				if err := s.Authors.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Statistics")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Statistics) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Statistics) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TeamMember) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TeamMember) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("team_id")
		e.Str(s.TeamID)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("role")
		e.Str(s.Role)
	}
	{
		if s.Permissions.Set {
			e.FieldStart("permissions")
			s.Permissions.Encode(e)
		}
	}
	{
		e.FieldStart("accepted")
		e.Bool(s.Accepted)
	}
	{
		if s.PayoutsSplit.Set {
			e.FieldStart("payouts_split")
			s.PayoutsSplit.Encode(e)
		}
	}
	{
		if s.Ordering.Set {
			e.FieldStart("ordering")
			s.Ordering.Encode(e)
		}
	}
}

var jsonFieldsNameOfTeamMember = [7]string{
	0: "team_id",
	1: "user",
	2: "role",
	3: "permissions",
	4: "accepted",
	5: "payouts_split",
	6: "ordering",
}

// Decode decodes TeamMember from json.
func (s *TeamMember) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TeamMember to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "team_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TeamID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"team_id\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "role":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Role = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "permissions":
			if err := func() error {
				s.Permissions.Reset()
				if err := s.Permissions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"permissions\"")
			}
		case "accepted":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.Accepted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accepted\"")
			}
		case "payouts_split":
			if err := func() error {
				s.PayoutsSplit.Reset()
				if err := s.PayoutsSplit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payouts_split\"")
			}
		case "ordering":
			if err := func() error {
				s.Ordering.Reset()
				if err := s.Ordering.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ordering\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TeamMember")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTeamMember) {
					name = jsonFieldsNameOfTeamMember[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TeamMember) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TeamMember) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Thread) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Thread) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.ReportID.Set {
			e.FieldStart("report_id")
			s.ReportID.Encode(e)
		}
	}
	{
		e.FieldStart("messages")
		e.ArrStart()
		for _, elem := range s.Messages {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("members")
		e.ArrStart()
		for _, elem := range s.Members {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfThread = [6]string{
	0: "id",
	1: "type",
	2: "project_id",
	3: "report_id",
	4: "messages",
	5: "members",
}

// Decode decodes Thread from json.
func (s *Thread) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Thread to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "report_id":
			if err := func() error {
				s.ReportID.Reset()
				if err := s.ReportID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"report_id\"")
			}
		case "messages":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Messages = make([]ThreadMessage, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ThreadMessage
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Messages = append(s.Messages, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"messages\"")
			}
		case "members":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.Members = make([]User, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem User
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Members = append(s.Members, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"members\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Thread")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThread) {
					name = jsonFieldsNameOfThread[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Thread) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Thread) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThreadMessage) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThreadMessage) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.AuthorID.Set {
			e.FieldStart("author_id")
			s.AuthorID.Encode(e)
		}
	}
	{
		e.FieldStart("body")
		s.Body.Encode(e)
	}
	{
		e.FieldStart("created")
		e.Str(s.Created)
	}
}

var jsonFieldsNameOfThreadMessage = [4]string{
	0: "id",
	1: "author_id",
	2: "body",
	3: "created",
}

// Decode decodes ThreadMessage from json.
func (s *ThreadMessage) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadMessage to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "author_id":
			if err := func() error {
				s.AuthorID.Reset()
				if err := s.AuthorID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_id\"")
			}
		case "body":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "created":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Created = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThreadMessage")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThreadMessage) {
					name = jsonFieldsNameOfThreadMessage[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThreadMessage) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadMessage) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ThreadMessageBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ThreadMessageBody) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("type")
		s.Type.Encode(e)
	}
	{
		if s.Body.Set {
			e.FieldStart("body")
			s.Body.Encode(e)
		}
	}
	{
		if s.Private.Set {
			e.FieldStart("private")
			s.Private.Encode(e)
		}
	}
	{
		if s.ReplyingTo.Set {
			e.FieldStart("replying_to")
			s.ReplyingTo.Encode(e)
		}
	}
	{
		if s.OldStatus.Set {
			e.FieldStart("old_status")
			s.OldStatus.Encode(e)
		}
	}
	{
		if s.NewStatus.Set {
			e.FieldStart("new_status")
			s.NewStatus.Encode(e)
		}
	}
}

var jsonFieldsNameOfThreadMessageBody = [6]string{
	0: "type",
	1: "body",
	2: "private",
	3: "replying_to",
	4: "old_status",
	5: "new_status",
}

// Decode decodes ThreadMessageBody from json.
func (s *ThreadMessageBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadMessageBody to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "body":
			if err := func() error {
				s.Body.Reset()
				if err := s.Body.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"body\"")
			}
		case "private":
			if err := func() error {
				s.Private.Reset()
				if err := s.Private.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"private\"")
			}
		case "replying_to":
			if err := func() error {
				s.ReplyingTo.Reset()
				if err := s.ReplyingTo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"replying_to\"")
			}
		case "old_status":
			if err := func() error {
				s.OldStatus.Reset()
				if err := s.OldStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"old_status\"")
			}
		case "new_status":
			if err := func() error {
				s.NewStatus.Reset()
				if err := s.NewStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"new_status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ThreadMessageBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfThreadMessageBody) {
					name = jsonFieldsNameOfThreadMessageBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ThreadMessageBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadMessageBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThreadMessageBodyNewStatus as json.
func (s ThreadMessageBodyNewStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ThreadMessageBodyNewStatus from json.
func (s *ThreadMessageBodyNewStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadMessageBodyNewStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ThreadMessageBodyNewStatus(v) {
	case ThreadMessageBodyNewStatusApproved:
		*s = ThreadMessageBodyNewStatusApproved
	case ThreadMessageBodyNewStatusArchived:
		*s = ThreadMessageBodyNewStatusArchived
	case ThreadMessageBodyNewStatusRejected:
		*s = ThreadMessageBodyNewStatusRejected
	case ThreadMessageBodyNewStatusDraft:
		*s = ThreadMessageBodyNewStatusDraft
	case ThreadMessageBodyNewStatusUnlisted:
		*s = ThreadMessageBodyNewStatusUnlisted
	case ThreadMessageBodyNewStatusProcessing:
		*s = ThreadMessageBodyNewStatusProcessing
	case ThreadMessageBodyNewStatusWithheld:
		*s = ThreadMessageBodyNewStatusWithheld
	case ThreadMessageBodyNewStatusScheduled:
		*s = ThreadMessageBodyNewStatusScheduled
	case ThreadMessageBodyNewStatusPrivate:
		*s = ThreadMessageBodyNewStatusPrivate
	case ThreadMessageBodyNewStatusUnknown:
		*s = ThreadMessageBodyNewStatusUnknown
	default:
		*s = ThreadMessageBodyNewStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ThreadMessageBodyNewStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadMessageBodyNewStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThreadMessageBodyOldStatus as json.
func (s ThreadMessageBodyOldStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ThreadMessageBodyOldStatus from json.
func (s *ThreadMessageBodyOldStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadMessageBodyOldStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ThreadMessageBodyOldStatus(v) {
	case ThreadMessageBodyOldStatusApproved:
		*s = ThreadMessageBodyOldStatusApproved
	case ThreadMessageBodyOldStatusArchived:
		*s = ThreadMessageBodyOldStatusArchived
	case ThreadMessageBodyOldStatusRejected:
		*s = ThreadMessageBodyOldStatusRejected
	case ThreadMessageBodyOldStatusDraft:
		*s = ThreadMessageBodyOldStatusDraft
	case ThreadMessageBodyOldStatusUnlisted:
		*s = ThreadMessageBodyOldStatusUnlisted
	case ThreadMessageBodyOldStatusProcessing:
		*s = ThreadMessageBodyOldStatusProcessing
	case ThreadMessageBodyOldStatusWithheld:
		*s = ThreadMessageBodyOldStatusWithheld
	case ThreadMessageBodyOldStatusScheduled:
		*s = ThreadMessageBodyOldStatusScheduled
	case ThreadMessageBodyOldStatusPrivate:
		*s = ThreadMessageBodyOldStatusPrivate
	case ThreadMessageBodyOldStatusUnknown:
		*s = ThreadMessageBodyOldStatusUnknown
	default:
		*s = ThreadMessageBodyOldStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ThreadMessageBodyOldStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadMessageBodyOldStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThreadMessageBodyType as json.
func (s ThreadMessageBodyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ThreadMessageBodyType from json.
func (s *ThreadMessageBodyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadMessageBodyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ThreadMessageBodyType(v) {
	case ThreadMessageBodyTypeStatusChange:
		*s = ThreadMessageBodyTypeStatusChange
	case ThreadMessageBodyTypeText:
		*s = ThreadMessageBodyTypeText
	case ThreadMessageBodyTypeThreadClosure:
		*s = ThreadMessageBodyTypeThreadClosure
	case ThreadMessageBodyTypeDeleted:
		*s = ThreadMessageBodyTypeDeleted
	default:
		*s = ThreadMessageBodyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ThreadMessageBodyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadMessageBodyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ThreadType as json.
func (s ThreadType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ThreadType from json.
func (s *ThreadType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ThreadType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ThreadType(v) {
	case ThreadTypeProject:
		*s = ThreadTypeProject
	case ThreadTypeReport:
		*s = ThreadTypeReport
	case ThreadTypeDirectMessage:
		*s = ThreadTypeDirectMessage
	default:
		*s = ThreadType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ThreadType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ThreadType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *User) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *User) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Bio.Set {
			e.FieldStart("bio")
			s.Bio.Encode(e)
		}
	}
	{
		if s.PayoutData.Set {
			e.FieldStart("payout_data")
			s.PayoutData.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("avatar_url")
		e.Str(s.AvatarURL)
	}
	{
		e.FieldStart("created")
		e.Str(s.Created)
	}
	{
		e.FieldStart("role")
		s.Role.Encode(e)
	}
	{
		if s.Badges.Set {
			e.FieldStart("badges")
			s.Badges.Encode(e)
		}
	}
	{
		if s.AuthProviders.Set {
			e.FieldStart("auth_providers")
			s.AuthProviders.Encode(e)
		}
	}
	{
		if s.EmailVerified.Set {
			e.FieldStart("email_verified")
			s.EmailVerified.Encode(e)
		}
	}
	{
		if s.HasPassword.Set {
			e.FieldStart("has_password")
			s.HasPassword.Encode(e)
		}
	}
	{
		if s.HasTotp.Set {
			e.FieldStart("has_totp")
			s.HasTotp.Encode(e)
		}
	}
	{
		if s.GithubID.Set {
			e.FieldStart("github_id")
			s.GithubID.Encode(e)
		}
	}
}

var jsonFieldsNameOfUser = [15]string{
	0:  "username",
	1:  "name",
	2:  "email",
	3:  "bio",
	4:  "payout_data",
	5:  "id",
	6:  "avatar_url",
	7:  "created",
	8:  "role",
	9:  "badges",
	10: "auth_providers",
	11: "email_verified",
	12: "has_password",
	13: "has_totp",
	14: "github_id",
}

// Decode decodes User from json.
func (s *User) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode User to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "bio":
			if err := func() error {
				s.Bio.Reset()
				if err := s.Bio.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bio\"")
			}
		case "payout_data":
			if err := func() error {
				s.PayoutData.Reset()
				if err := s.PayoutData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payout_data\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "avatar_url":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.AvatarURL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"avatar_url\"")
			}
		case "created":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Created = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "role":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Role.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"role\"")
			}
		case "badges":
			if err := func() error {
				s.Badges.Reset()
				if err := s.Badges.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"badges\"")
			}
		case "auth_providers":
			if err := func() error {
				s.AuthProviders.Reset()
				if err := s.AuthProviders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_providers\"")
			}
		case "email_verified":
			if err := func() error {
				s.EmailVerified.Reset()
				if err := s.EmailVerified.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email_verified\"")
			}
		case "has_password":
			if err := func() error {
				s.HasPassword.Reset()
				if err := s.HasPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_password\"")
			}
		case "has_totp":
			if err := func() error {
				s.HasTotp.Reset()
				if err := s.HasTotp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"has_totp\"")
			}
		case "github_id":
			if err := func() error {
				s.GithubID.Reset()
				if err := s.GithubID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"github_id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode User")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11100001,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUser) {
					name = jsonFieldsNameOfUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *User) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *User) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserIdentifier as json.
func (s UserIdentifier) Encode(e *jx.Encoder) {
	unwrapped := jx.Raw(s)

	if len(unwrapped) != 0 {
		e.Raw(unwrapped)
	}
}

// Decode decodes UserIdentifier from json.
func (s *UserIdentifier) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserIdentifier to nil")
	}
	var unwrapped jx.Raw
	if err := func() error {
		v, err := d.RawAppend(nil)
		unwrapped = jx.Raw(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = UserIdentifier(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserIdentifier) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserIdentifier) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserPayoutData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserPayoutData) encodeFields(e *jx.Encoder) {
	{
		if s.Balance.Set {
			e.FieldStart("balance")
			s.Balance.Encode(e)
		}
	}
	{
		if s.PayoutWallet.Set {
			e.FieldStart("payout_wallet")
			s.PayoutWallet.Encode(e)
		}
	}
	{
		if s.PayoutWalletType.Set {
			e.FieldStart("payout_wallet_type")
			s.PayoutWalletType.Encode(e)
		}
	}
	{
		if s.PayoutAddress.Set {
			e.FieldStart("payout_address")
			s.PayoutAddress.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserPayoutData = [4]string{
	0: "balance",
	1: "payout_wallet",
	2: "payout_wallet_type",
	3: "payout_address",
}

// Decode decodes UserPayoutData from json.
func (s *UserPayoutData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserPayoutData to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "balance":
			if err := func() error {
				s.Balance.Reset()
				if err := s.Balance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"balance\"")
			}
		case "payout_wallet":
			if err := func() error {
				s.PayoutWallet.Reset()
				if err := s.PayoutWallet.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payout_wallet\"")
			}
		case "payout_wallet_type":
			if err := func() error {
				s.PayoutWalletType.Reset()
				if err := s.PayoutWalletType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payout_wallet_type\"")
			}
		case "payout_address":
			if err := func() error {
				s.PayoutAddress.Reset()
				if err := s.PayoutAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payout_address\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserPayoutData")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserPayoutData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserPayoutData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserPayoutDataPayoutWallet as json.
func (s UserPayoutDataPayoutWallet) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserPayoutDataPayoutWallet from json.
func (s *UserPayoutDataPayoutWallet) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserPayoutDataPayoutWallet to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserPayoutDataPayoutWallet(v) {
	case UserPayoutDataPayoutWalletPaypal:
		*s = UserPayoutDataPayoutWalletPaypal
	case UserPayoutDataPayoutWalletVenmo:
		*s = UserPayoutDataPayoutWalletVenmo
	default:
		*s = UserPayoutDataPayoutWallet(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserPayoutDataPayoutWallet) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserPayoutDataPayoutWallet) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserPayoutDataPayoutWalletType as json.
func (s UserPayoutDataPayoutWalletType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserPayoutDataPayoutWalletType from json.
func (s *UserPayoutDataPayoutWalletType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserPayoutDataPayoutWalletType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserPayoutDataPayoutWalletType(v) {
	case UserPayoutDataPayoutWalletTypeEmail:
		*s = UserPayoutDataPayoutWalletTypeEmail
	case UserPayoutDataPayoutWalletTypePhone:
		*s = UserPayoutDataPayoutWalletTypePhone
	case UserPayoutDataPayoutWalletTypeUserHandle:
		*s = UserPayoutDataPayoutWalletTypeUserHandle
	default:
		*s = UserPayoutDataPayoutWalletType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserPayoutDataPayoutWalletType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserPayoutDataPayoutWalletType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserPayoutHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserPayoutHistory) encodeFields(e *jx.Encoder) {
	{
		if s.AllTime.Set {
			e.FieldStart("all_time")
			s.AllTime.Encode(e)
		}
	}
	{
		if s.LastMonth.Set {
			e.FieldStart("last_month")
			s.LastMonth.Encode(e)
		}
	}
	{
		if s.Payouts != nil {
			e.FieldStart("payouts")
			e.ArrStart()
			for _, elem := range s.Payouts {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUserPayoutHistory = [3]string{
	0: "all_time",
	1: "last_month",
	2: "payouts",
}

// Decode decodes UserPayoutHistory from json.
func (s *UserPayoutHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserPayoutHistory to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "all_time":
			if err := func() error {
				s.AllTime.Reset()
				if err := s.AllTime.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"all_time\"")
			}
		case "last_month":
			if err := func() error {
				s.LastMonth.Reset()
				if err := s.LastMonth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_month\"")
			}
		case "payouts":
			if err := func() error {
				s.Payouts = make([]UserPayoutHistoryEntry, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserPayoutHistoryEntry
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Payouts = append(s.Payouts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"payouts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserPayoutHistory")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserPayoutHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserPayoutHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserPayoutHistoryEntry) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserPayoutHistoryEntry) encodeFields(e *jx.Encoder) {
	{
		if s.Created.Set {
			e.FieldStart("created")
			s.Created.Encode(e)
		}
	}
	{
		if s.Amount.Set {
			e.FieldStart("amount")
			s.Amount.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserPayoutHistoryEntry = [3]string{
	0: "created",
	1: "amount",
	2: "status",
}

// Decode decodes UserPayoutHistoryEntry from json.
func (s *UserPayoutHistoryEntry) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserPayoutHistoryEntry to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "created":
			if err := func() error {
				s.Created.Reset()
				if err := s.Created.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"created\"")
			}
		case "amount":
			if err := func() error {
				s.Amount.Reset()
				if err := s.Amount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserPayoutHistoryEntry")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserPayoutHistoryEntry) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserPayoutHistoryEntry) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserRole as json.
func (s UserRole) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserRole from json.
func (s *UserRole) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserRole to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserRole(v) {
	case UserRoleAdmin:
		*s = UserRoleAdmin
	case UserRoleModerator:
		*s = UserRoleModerator
	case UserRoleDeveloper:
		*s = UserRoleDeveloper
	default:
		*s = UserRole(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserRole) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserRole) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Version) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Version) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("version_number")
		e.Str(s.VersionNumber)
	}
	{
		if s.Changelog.Set {
			e.FieldStart("changelog")
			s.Changelog.Encode(e)
		}
	}
	{
		if s.Dependencies != nil {
			e.FieldStart("dependencies")
			e.ArrStart()
			for _, elem := range s.Dependencies {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		e.FieldStart("game_versions")
		e.ArrStart()
		for _, elem := range s.GameVersions {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("version_type")
		s.VersionType.Encode(e)
	}
	{
		e.FieldStart("loaders")
		e.ArrStart()
		for _, elem := range s.Loaders {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("featured")
		e.Bool(s.Featured)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.RequestedStatus.Set {
			e.FieldStart("requested_status")
			s.RequestedStatus.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("project_id")
		e.Str(s.ProjectID)
	}
	{
		e.FieldStart("author_id")
		e.Str(s.AuthorID)
	}
	{
		e.FieldStart("date_published")
		e.Str(s.DatePublished)
	}
	{
		e.FieldStart("downloads")
		e.Int(s.Downloads)
	}
	{
		if s.ChangelogURL.Set {
			e.FieldStart("changelog_url")
			s.ChangelogURL.Encode(e)
		}
	}
	{
		e.FieldStart("files")
		e.ArrStart()
		for _, elem := range s.Files {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfVersion = [17]string{
	0:  "name",
	1:  "version_number",
	2:  "changelog",
	3:  "dependencies",
	4:  "game_versions",
	5:  "version_type",
	6:  "loaders",
	7:  "featured",
	8:  "status",
	9:  "requested_status",
	10: "id",
	11: "project_id",
	12: "author_id",
	13: "date_published",
	14: "downloads",
	15: "changelog_url",
	16: "files",
}

// Decode decodes Version from json.
func (s *Version) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Version to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "version_number":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.VersionNumber = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_number\"")
			}
		case "changelog":
			if err := func() error {
				s.Changelog.Reset()
				if err := s.Changelog.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changelog\"")
			}
		case "dependencies":
			if err := func() error {
				s.Dependencies = make([]VersionDependency, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VersionDependency
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Dependencies = append(s.Dependencies, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependencies\"")
			}
		case "game_versions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.GameVersions = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.GameVersions = append(s.GameVersions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"game_versions\"")
			}
		case "version_type":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.VersionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_type\"")
			}
		case "loaders":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.Loaders = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Loaders = append(s.Loaders, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loaders\"")
			}
		case "featured":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.Featured = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"featured\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "requested_status":
			if err := func() error {
				s.RequestedStatus.Reset()
				if err := s.RequestedStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requested_status\"")
			}
		case "id":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "project_id":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ProjectID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "author_id":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.AuthorID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"author_id\"")
			}
		case "date_published":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.DatePublished = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date_published\"")
			}
		case "downloads":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Int()
				s.Downloads = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloads\"")
			}
		case "changelog_url":
			if err := func() error {
				s.ChangelogURL.Reset()
				if err := s.ChangelogURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"changelog_url\"")
			}
		case "files":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				s.Files = make([]VersionFile, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem VersionFile
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Files = append(s.Files, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"files\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Version")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11110011,
		0b01111100,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVersion) {
					name = jsonFieldsNameOfVersion[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Version) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Version) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VersionDependency) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VersionDependency) encodeFields(e *jx.Encoder) {
	{
		if s.VersionID.Set {
			e.FieldStart("version_id")
			s.VersionID.Encode(e)
		}
	}
	{
		if s.ProjectID.Set {
			e.FieldStart("project_id")
			s.ProjectID.Encode(e)
		}
	}
	{
		if s.FileName.Set {
			e.FieldStart("file_name")
			s.FileName.Encode(e)
		}
	}
	{
		e.FieldStart("dependency_type")
		s.DependencyType.Encode(e)
	}
}

var jsonFieldsNameOfVersionDependency = [4]string{
	0: "version_id",
	1: "project_id",
	2: "file_name",
	3: "dependency_type",
}

// Decode decodes VersionDependency from json.
func (s *VersionDependency) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionDependency to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version_id":
			if err := func() error {
				s.VersionID.Reset()
				if err := s.VersionID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version_id\"")
			}
		case "project_id":
			if err := func() error {
				s.ProjectID.Reset()
				if err := s.ProjectID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"project_id\"")
			}
		case "file_name":
			if err := func() error {
				s.FileName.Reset()
				if err := s.FileName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_name\"")
			}
		case "dependency_type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.DependencyType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dependency_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VersionDependency")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVersionDependency) {
					name = jsonFieldsNameOfVersionDependency[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VersionDependency) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionDependency) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VersionDependencyDependencyType as json.
func (s VersionDependencyDependencyType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VersionDependencyDependencyType from json.
func (s *VersionDependencyDependencyType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionDependencyDependencyType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VersionDependencyDependencyType(v) {
	case VersionDependencyDependencyTypeRequired:
		*s = VersionDependencyDependencyTypeRequired
	case VersionDependencyDependencyTypeOptional:
		*s = VersionDependencyDependencyTypeOptional
	case VersionDependencyDependencyTypeIncompatible:
		*s = VersionDependencyDependencyTypeIncompatible
	case VersionDependencyDependencyTypeEmbedded:
		*s = VersionDependencyDependencyTypeEmbedded
	default:
		*s = VersionDependencyDependencyType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VersionDependencyDependencyType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionDependencyDependencyType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VersionFile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VersionFile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hashes")
		s.Hashes.Encode(e)
	}
	{
		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		e.FieldStart("filename")
		e.Str(s.Filename)
	}
	{
		e.FieldStart("primary")
		e.Bool(s.Primary)
	}
	{
		e.FieldStart("size")
		e.Int(s.Size)
	}
	{
		if s.FileType.Set {
			e.FieldStart("file_type")
			s.FileType.Encode(e)
		}
	}
}

var jsonFieldsNameOfVersionFile = [6]string{
	0: "hashes",
	1: "url",
	2: "filename",
	3: "primary",
	4: "size",
	5: "file_type",
}

// Decode decodes VersionFile from json.
func (s *VersionFile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionFile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hashes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Hashes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hashes\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "filename":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Filename = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"filename\"")
			}
		case "primary":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.Primary = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"primary\"")
			}
		case "size":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Size = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"size\"")
			}
		case "file_type":
			if err := func() error {
				s.FileType.Reset()
				if err := s.FileType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"file_type\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VersionFile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVersionFile) {
					name = jsonFieldsNameOfVersionFile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VersionFile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionFile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VersionFileFileType as json.
func (s VersionFileFileType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VersionFileFileType from json.
func (s *VersionFileFileType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionFileFileType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VersionFileFileType(v) {
	case VersionFileFileTypeRequiredResourcePack:
		*s = VersionFileFileTypeRequiredResourcePack
	case VersionFileFileTypeOptionalResourcePack:
		*s = VersionFileFileTypeOptionalResourcePack
	default:
		*s = VersionFileFileType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VersionFileFileType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionFileFileType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VersionFileHashes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VersionFileHashes) encodeFields(e *jx.Encoder) {
	{
		if s.Sha512.Set {
			e.FieldStart("sha512")
			s.Sha512.Encode(e)
		}
	}
	{
		if s.SHA1.Set {
			e.FieldStart("sha1")
			s.SHA1.Encode(e)
		}
	}
}

var jsonFieldsNameOfVersionFileHashes = [2]string{
	0: "sha512",
	1: "sha1",
}

// Decode decodes VersionFileHashes from json.
func (s *VersionFileHashes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionFileHashes to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "sha512":
			if err := func() error {
				s.Sha512.Reset()
				if err := s.Sha512.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha512\"")
			}
		case "sha1":
			if err := func() error {
				s.SHA1.Reset()
				if err := s.SHA1.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sha1\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VersionFileHashes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VersionFileHashes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionFileHashes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VersionRequestedStatus as json.
func (s VersionRequestedStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VersionRequestedStatus from json.
func (s *VersionRequestedStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionRequestedStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VersionRequestedStatus(v) {
	case VersionRequestedStatusListed:
		*s = VersionRequestedStatusListed
	case VersionRequestedStatusArchived:
		*s = VersionRequestedStatusArchived
	case VersionRequestedStatusDraft:
		*s = VersionRequestedStatusDraft
	case VersionRequestedStatusUnlisted:
		*s = VersionRequestedStatusUnlisted
	default:
		*s = VersionRequestedStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VersionRequestedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionRequestedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VersionStatus as json.
func (s VersionStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VersionStatus from json.
func (s *VersionStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VersionStatus(v) {
	case VersionStatusListed:
		*s = VersionStatusListed
	case VersionStatusArchived:
		*s = VersionStatusArchived
	case VersionStatusDraft:
		*s = VersionStatusDraft
	case VersionStatusUnlisted:
		*s = VersionStatusUnlisted
	case VersionStatusScheduled:
		*s = VersionStatusScheduled
	case VersionStatusUnknown:
		*s = VersionStatusUnknown
	default:
		*s = VersionStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VersionStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes VersionVersionType as json.
func (s VersionVersionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes VersionVersionType from json.
func (s *VersionVersionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VersionVersionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch VersionVersionType(v) {
	case VersionVersionTypeRelease:
		*s = VersionVersionTypeRelease
	case VersionVersionTypeBeta:
		*s = VersionVersionTypeBeta
	case VersionVersionTypeAlpha:
		*s = VersionVersionTypeAlpha
	default:
		*s = VersionVersionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s VersionVersionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VersionVersionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
